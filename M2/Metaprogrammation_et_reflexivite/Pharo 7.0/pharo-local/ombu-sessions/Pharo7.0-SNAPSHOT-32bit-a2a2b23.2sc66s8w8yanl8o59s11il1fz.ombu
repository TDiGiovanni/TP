OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T13:58:19.437247+02:00' ],		#prior : OmReference [ 'Pharo7.0-SNAPSHOT-32bit-a2a2b23.9phosdalaloas4htzqkd0aumi', '15' ],		#self : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'PackageManifest',				#definitionSource : 'PackageManifest subclass: #ManifestMetaprogrammation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Metaprogrammation\''			},			#name : #ManifestMetaprogrammation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestMetaprogrammation class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestMetaprogrammation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestMetaprogrammation,					#isMetaSide : false				},				#parent : @7,				#content : 'HMIN30? - Metaprogrammation et reflexivite',				#stamp : 'ThomasDiGiovanni 9/26/2019 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #Metaprogrammation,			#package : #Metaprogrammation,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'HMIN30? - Metaprogrammation et reflexivite',		#newStamp : 'ThomasDiGiovanni 9/26/2019 13:58'	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T14:00:51.677247+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'PackageManifest',				#definitionSource : 'PackageManifest subclass: #ManifestMetaprogrammation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Metaprogrammation\''			},			#name : #ManifestMetaprogrammation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestMetaprogrammation class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestMetaprogrammation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestMetaprogrammation,					#isMetaSide : false				},				#parent : @7,				#content : 'HMIN305 - Metaprogrammation et reflexivite',				#stamp : 'ThomasDiGiovanni 9/26/2019 14:00'			},			#classVariables : OrderedCollection [ ],			#category : #Metaprogrammation,			#package : #Metaprogrammation,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'HMIN30? - Metaprogrammation et reflexivite',		#newComment : 'HMIN305 - Metaprogrammation et reflexivite',		#oldStamp : 'ThomasDiGiovanni 9/26/2019 13:58',		#newStamp : 'ThomasDiGiovanni 9/26/2019 14:00'	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T14:01:27.674247+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Object',				#definitionSource : 'Object subclass: #Counter\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Metaprogrammation\''			},			#name : #Counter,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Counter class\r\tinstanceVariableNames: \'\''				},				#name : #'Counter class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Counter,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #Metaprogrammation,			#package : #Metaprogrammation,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T14:02:16.250247+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Counter,				#isMetaSide : false			},			#name : #create,			#protocol : #'as yet unclassified',			#sourceCode : 'create\r\t|x|\r\tx := 0.\r\t^ [x :=x+ 1 ]',			#stamp : 'ThomasDiGiovanni 9/26/2019 14:02',			#package : #Metaprogrammation		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T14:02:16.266247+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Counter,				#isMetaSide : false			},			#name : #create,			#protocol : #'as yet unclassified',			#sourceCode : 'create\r\t|x|\r\tx := 0.\r\t^ [x :=x+ 1 ]',			#stamp : 'ThomasDiGiovanni 9/26/2019 14:02',			#package : #Metaprogrammation		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Counter,				#isMetaSide : false			},			#name : #create,			#protocol : #operations,			#sourceCode : 'create\r\t|x|\r\tx := 0.\r\t^ [x :=x+ 1 ]',			#stamp : 'ThomasDiGiovanni 9/26/2019 14:02',			#package : #Metaprogrammation		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:37:01.738247+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'IfNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'IfNotTrue: alternativeBlock\r\t"If the receiver is true (i.e., the condition is true), then the value is the \r\ttrue alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:37',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:37:35.486247+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"If the receiver is false (i.e., the condition is false), then the value is the \r\tfalse alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:37',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:38:22.414247+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Since the condition is false, answer the value of the false alternative, \r\twhich is nil. Execution does not actually reach here because the\r\texpression is compiled in-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:38:44.074247+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifFalse:',			#protocol : #controlling,			#sourceCode : 'ifFalse: alternativeBlock \r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^alternativeBlock value',			#stamp : '',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifFalse:',			#protocol : #controlling,			#sourceCode : 'ifFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:38:44.076247+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifFalse:',			#protocol : #controlling,			#sourceCode : 'ifFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:39:32.923247+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifFalse:',			#protocol : #controlling,			#sourceCode : 'ifFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:39:56.822247+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'IfNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'IfNotTrue: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:39',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:40:11.096247+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"If the receiver is true (i.e., the condition is true), then the value is the \r\ttrue alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:40',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:40:18.965247+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'IfNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'IfNotTrue: alternativeBlock\r\t"If the receiver is true (i.e., the condition is true), then the value is the \r\ttrue alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:37',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:40:28.621247+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:40',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:40:33.237247+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'IfNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'IfNotTrue: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:39',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:41:06.758247+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually \r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:41',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:41:22.601247+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually \r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:41',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Since the condition is true, the value is the true alternative, which is nil. \r\tExecution does not actually reach here because the expression is compiled \r\tin-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:41',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:42:36.886247+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Since the condition is true, the value is the true alternative, which is nil. \r\tExecution does not actually reach here because the expression is compiled \r\tin-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:41',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually \r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:42',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:42:51.895247+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"Since the condition is true, the value is the true alternative, which is nil. \r\tExecution does not actually reach here because the expression is compiled \r\tin-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:42',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:43:14.247247+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"Since the condition is true, the value is the true alternative, which is nil. \r\tExecution does not actually reach here because the expression is compiled \r\tin-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:42',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #controlling,			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"Since the condition is true, the value is the true alternative, which is nil. \r\tExecution does not actually reach here because the expression is compiled \r\tin-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:42',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:43:24.970247+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually \r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:42',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #controlling,			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually \r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:42',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:44:12.109247+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Since the condition is false, answer the value of the false alternative, \r\twhich is nil. Execution does not actually reach here because the\r\texpression is compiled in-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #controlling,			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"Since the condition is false, answer the value of the false alternative, \r\twhich is nil. Execution does not actually reach here because the\r\texpression is compiled in-line."\r\r\t^ nil',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:38',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:44:21.333247+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:40',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #controlling,			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"Answer the value of alternativeBlock. Execution does not actually\r\treach here because the expression is compiled in-line."\r\r\t^ alternativeBlock value',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:40',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:44:32.527247+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"If the receiver is true (i.e., the condition is true), then the value is the \r\ttrue alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:40',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'ifNotTrue:',			#protocol : #controlling,			#sourceCode : 'ifNotTrue: alternativeBlock\r\t"If the receiver is true (i.e., the condition is true), then the value is the \r\ttrue alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:40',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T22:44:38.823247+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #'as yet unclassified',			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"If the receiver is false (i.e., the condition is false), then the value is the \r\tfalse alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:37',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Boolean,				#isMetaSide : false			},			#name : #'ifNotFalse:',			#protocol : #controlling,			#sourceCode : 'ifNotFalse: alternativeBlock\r\t"If the receiver is false (i.e., the condition is false), then the value is the \r\tfalse alternative, which is nil. Otherwise answer the result of evaluating \r\tthe argument, alternativeBlock. Create an error notification if the \r\treceiver is nonBoolean. Execution does not actually reach here because \r\tthe expression is compiled in-line."\r\r\tself subclassResponsibility',			#stamp : 'ThomasDiGiovanni 9/26/2019 22:37',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T23:08:01.687247+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BlockClosure,				#isMetaSide : false			},			#name : #repeatUntil,			#protocol : #'as yet unclassified',			#sourceCode : 'repeatUntil\r\r^ \'TODO\'',			#stamp : 'ThomasDiGiovanni 9/26/2019 23:08',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'ThomasDiGiovanni',		#time : DateAndTime [ '2019-09-26T23:08:43.753247+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BlockClosure,				#isMetaSide : false			},			#name : #repeatUntil,			#protocol : #'as yet unclassified',			#sourceCode : 'repeatUntil\r\r^ \'TODO\'',			#stamp : 'ThomasDiGiovanni 9/26/2019 23:08',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BlockClosure,				#isMetaSide : false			},			#name : #repeatUntil,			#protocol : #controlling,			#sourceCode : 'repeatUntil\r\r^ \'TODO\'',			#stamp : 'ThomasDiGiovanni 9/26/2019 23:08',			#package : #Kernel		}	}}