----QUIT----2019-08-22T08:52:26.88499+02:00 Pharo7.0-SNAPSHOT-32bit-a2a2b23.image priorSource: 0!----QUIT----2019-08-22T08:52:42.036664+02:00 Pharo7.0-SNAPSHOT-32bit-a2a2b23.image priorSource: 0!!ManifestMetaprogrammation commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestMetaprogrammation commentStamp: 'ThomasDiGiovanni 9/20/2019 10:06' prior: 33554698!HMIN305 - Métaprogrammation et réflexivité!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	package: 'Metaprogrammation'!!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:08'!initialize: taille"la pile est vide quand index = 0"index := 0."la pile est pleine quand index = capacite"capacite := taille."le contenu est stocké dans un tableau"contenu := Array new: capacite."pour les tests, enlever le commentaire quand isEmpty est écrite""self assert: (self isEmpty)."! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 9/20/2019 10:09' prior: 33555198!initialize: taille	"La pile est vide quand index = 0, la pile est pleine quand index = capacite"	index := 0.	capacite := taille.		"Le contenu est stocké dans un tableau"	contenu := Array new: capacite		"pour les tests, enlever le commentaire quand isEmpty est écrite"	"self assert: (self isEmpty)."! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 9/20/2019 10:09' prior: 33555596!initialize: taille	"La pile est vide quand index = 0, la pile est pleine quand index = capacite"	index := 0.	capacite := taille.	"Le contenu est stocké dans un tableau"	contenu := Array new: capacite	"Pour les tests, enlever le commentaire quand isEmpty est écrite"	"self assert: (self isEmpty)."! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 9/20/2019 10:10'!printOn: aStreamaStream nextPutAll: 'une Pile, de taille: '.capacite printOn: aStream.aStream nextPutAll: ' contenant: '.index printOn: aStream.aStream nextPutAll: ' objets : ('.contenu do: [ :each | each printOn: aStream. aStream space ].aStream nextPut: $).aStream nextPut: $..! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 9/20/2019 10:13'!isEmpty! !Pile removeSelector: #isEmpty!Pile removeSelector: #printOn:!!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:14'!printOn: aStreamaStream nextPutAll: 'une Pile, de taille: '.capacite printOn: aStream.aStream nextPutAll: ' contenant: '.index printOn: aStream.aStream nextPutAll: ' objets : ('.contenu do: [ :each | each printOn: aStream. aStream space ].aStream nextPut: $).aStream nextPut: $.! !!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:14'!isEmpty! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 9/20/2019 10:15' prior: 33557296!isEmpty	^(contenu = 0)! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 9/20/2019 10:16'!isFull	^ contenu = capacite! !!Pile commentStamp: 'ThomasDiGiovanni 9/20/2019 10:16' prior: 0!Implémentation d'une pile!!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:18'!push: object	contenu := object! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 9/20/2019 10:18' prior: 33557494!isFull	^ index = capacite! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 9/20/2019 10:18' prior: 33557395!isEmpty	^ index = 0! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 10:19' prior: 33557702!push: object	self isFull	ifTrue: [ ^'Error: pile is full' ] ifFalse: [ contenu := object ]	! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 10:20' prior: 33558051!push: object	self isFull		ifTrue: [ ^ 'Error: pile is full' ]		ifFalse: [ contenu push: object ]! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 10:20' prior: 33558235!push: object	self isFull		ifTrue: [ ^ 'Error: pile is full' ]		ifFalse: [ contenu add: object ]! !!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:21'!pop ! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:21' prior: 33558609!pop	contenu at: index! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 10:27' prior: 33558424!push: object	self isFull		ifTrue: [ ^ 'Error: pile is full' ]		ifFalse: [ contenu add: object.			index := index + 1 ]! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:29' prior: 33558706!pop	contenu at: index.	! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:30' prior: 33559031!pop	self isEmpty ifTrue: [  ] ifFalse: [  ]! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:30' prior: 33559148!pop	self isEmpty		ifTrue: [ ^'Error: pile is empty' ]		ifFalse: [  ]! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:31' prior: 33559284!pop	self isEmpty		ifTrue: [ ^ 'Error: pile is empty' ]		ifFalse: [ contenu removeAtIndex: index ]! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:32' prior: 33559447!pop	self isEmpty		ifTrue: [ ^ 'Error: pile is empty' ]		ifFalse: [ contenu remove: index ]! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:32' prior: 33559639!pop	self isEmpty		ifTrue: [ ^ 'Error: pile is empty' ]		ifFalse: [ contenu remove: index.			index := index - 1 ]! !!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:33'!top ! !!Pile methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/20/2019 10:33' prior: 33560027!top^contenu at: index	! !!Pile methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/20/2019 10:33' prior: 33560125!top	^ contenu at: index - 1! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:35' prior: 33559824!pop	self isEmpty		ifTrue: [ ^ 'Error: pile is empty' ]		ifFalse: [ index := index - 1 ]! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 10:37' prior: 33560361!pop	self isEmpty		ifTrue: [ self error: 'pile is empty' ]		ifFalse: [ index := index - 1 ]! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 10:37' prior: 33558818!push: object	self isFull		ifTrue: [ self error: 'pile is full' ]		ifFalse: [ contenu add: object.			index := index + 1 ]! !!Pile methodsFor: 'printing' stamp: 'ThomasDiGiovanni 9/20/2019 10:37' prior: 33556923!printOn: aStream	aStream nextPutAll: 'Pile de taille : '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant : '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu		do: [ :each | 			each printOn: aStream.			aStream space ].	aStream nextPut: $).	aStream nextPut: $.! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 10:40' prior: 33560726!push: object	self isFull		ifTrue: [ self error: 'pile is full' ]		ifFalse: [ contenu at: index put: object.			index := index + 1 ]! !!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:44'!grow ! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/20/2019 10:44' prior: 33561553!grow	capacite := capacite * 2! !Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'TailleDefaut'	package: 'Metaprogrammation'!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'DefaultSize'	package: 'Metaprogrammation'!Object subclass: #TestPile	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation'!TestCase subclass: #TestPile	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation'!TestCase subclass: #TestPile	instanceVariableNames: 'empty full'	classVariableNames: ''	package: 'Metaprogrammation'!!TestPile methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 10:54'!setUp	empty := Pile new initialize: 0	! !!TestPile methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 10:54' prior: 33562382!setUp	empty := Pile new initialize: 3.	full := Pile new initialize: 1.! !!TestPile methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 10:55' prior: 33562517!setUp	empty := Pile new initialize: 3.	full := (Pile new initialize: 1) push: 'Test'.! !!TestPile methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 10:56' prior: 33562684!setUpsuper setUp.	empty := Pile new initialize: 3.	full := (Pile new initialize: 1) push: 'Test'! !TestCase subclass: #PileTest	instanceVariableNames: 'empty full'	classVariableNames: ''	package: 'Metaprogrammation'!Smalltalk globals removeClassNamed: #AnObsoletePileTest!(Smalltalk globals at: #TestPile) rename: #PileTest!!PileTest methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 10:57'!testInclude! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 10:58'!testOccurence	! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 10:58'!testRemove	! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 10:59' prior: 33563290!testInclude	self assert: (full includes: 'Test')! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 10:59' prior: 33563378!testOccurence	 self assert: (empty occurrencesOf: 'Test') = 0.     self assert: (full occurrencesOf: 5) = 1.     full add: 5.     self assert: (full occurrencesOf: 5) = 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:00' prior: 33563717!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 5) = 1.	full add: 5.	self assert: (full occurrencesOf: 5) = 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:00' prior: 33563984!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 5) equals: 1.	full add: 5.	self assert: (full occurrencesOf: 5) = 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:00' prior: 33564244!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 5) equals: 1.	full add: 5.	self assert: (full occurrencesOf: 5) equals: 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:01' prior: 33564510!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 5) equals: 1.	full at: 0 put:  'Pile'.	self assert: (full occurrencesOf: 5) equals: 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:01' prior: 33564782!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 'Test') equals: 1.	full at: 0 put: 'Pile'.	self assert: (full occurrencesOf: 'Pile') equals: 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:01' prior: 33565066!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 'Test') equals: 1.	full at: 0 put: 'Pile'.	self assert: (full occurrencesOf: 'Pile') equals: 1.	self assert: (full occurrencesOf: 'Test') equals: 0.! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:02' prior: 33563470!testRemove	    full remove: 5.     self assert: (full includes: 6).     self deny: (full includes: 5)! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:03' prior: 33565359!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 'Test') equals: 1.	full pop.	full push: 'Pile'.	self assert: (full occurrencesOf: 'Pile') equals: 1.	self assert: (full occurrencesOf: 'Test') equals: 0! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:03' prior: 33565707!testRemove	full pop.	self assert: (full includes: 6).	self deny: (full includes: 5)! !!PileTest methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 11:04' prior: 33562866!setUp	super setUp.	empty := Pile new initialize: 3.	full := (Pile new initialize: 2) push: 'Test'.	full push: 'Pile'! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:04' prior: 33565904!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 'Test') equals: 1.	self assert: (full occurrencesOf: 'Pile') equals: 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:05' prior: 33566257!testRemove	full pop.	self assert: (full occurrencesOf: 'Test') equals: 1.	self deny: (full includes: 'Pile')! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:05' prior: 33563575!testInclude	self assert: (full includes: 'Test')	self assert: (full includes: 'Pile')! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:05' prior: 33567123!testInclude	self assert: (full includes: 'Test').	self assert: (full includes: 'Pile')! !!PileTest methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 11:06' prior: 33566438!setUp	super setUp.	empty := Pile new initialize: 2.	full := (Pile new initialize: 2) push: 'Test'.	full push: 'Pile'! !!Pile class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 11:12'!initializeDefaultSize := 5! !!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 11:14'!new! !!Pile methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 11:15' prior: 33567813!new	self initialize: DefaultSize 	! !!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 11:16'!example! !!Pile methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:16' prior: 33568039!example	| testPile |testPile := Pile new initialize: 2.testPile isEmpty.testPile push: 'test'.testPile top.testPile pop.testPile push: 'pile'.testPile printOn: Transcript open! !!Pile methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:17' prior: 33568137!example	| testPile |	testPile := self new.	testPile isEmpty.	testPile push: 'test'.	testPile top.	testPile pop.	testPile push: 'pile'.	testPile printOn: Transcript open! !!Pile methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:17' prior: 33568411!example	| testPile |	testPile := self new.	testPile isEmpty.	testPile push: 1.	testPile pop.	testPile push: 2.	testPile printOn: Transcript open! !Pile removeSelector: #example!!Pile class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 11:18'!example	| testPile |	testPile := self new.	testPile isEmpty.	testPile push: 1.	testPile pop.	testPile push: 2.	testPile printOn: Transcript open! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:18' prior: 33568954!example	| testPile |	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile pop.	testPile push: 2.	testPile printOn: Transcript open! !!Pile methodsFor: 'printing' stamp: 'ThomasDiGiovanni 9/20/2019 11:19' prior: 33560942!printOn: aStream	aStream nextPutAll: 'Pile de taille '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu		do: [ :each | 			each printOn: aStream.			aStream space ].	aStream nextPut: $).	aStream nextPut: $.! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:21' prior: 33569202!example	| testPile |	Pile initialize .	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile pop.	testPile push: 2.	testPile printOn: Transcript open! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:21' prior: 33569851!example	| testPile |	self initialize.	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile pop.	testPile push: 2.	testPile printOn: Transcript open! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 9/20/2019 11:22' prior: 33556004!initialize: taille	"La pile est vide quand index = 0, la pile est pleine quand index = capacite"	index := 0.	capacite := taille.	"Le contenu est stocké dans un tableau"	contenu := Array new: capacite! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:25' prior: 33566651!testOccurence	self assert: (empty occurrencesOf: 1) equals: 0.	self assert: (full occurrencesOf: 1) equals: 1.	self assert: (full occurrencesOf: 2) equals: 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:25' prior: 33566919!testRemove	full pop.	self assert: (full occurrencesOf: 1) equals: 1.	self deny: (full includes: 2)! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:25' prior: 33567303!testInclude	self assert: (full includes: 1).	self assert: (full includes: 2)! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 11:27' prior: 33561332!push: object	self isFull		ifTrue: [ self error: 'pile is full' ]		ifFalse: [ contenu at: index + 1 put: object.			index := index + 1 ]! !!Pile methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/20/2019 11:27' prior: 33560241!top	^ contenu at: index! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:28' prior: 33571157!testInclude	self assert: (full includes: 'Test').	self assert: (full includes: 'Pile')! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:28' prior: 33570710!testOccurence	self assert: (empty occurrencesOf: 'Test') equals: 0.	self assert: (full occurrencesOf: 'Test') equals: 1.	self assert: (full occurrencesOf: 'Pile') equals: 1! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 11:29' prior: 33570963!testRemove	full pop.	self assert: (full occurrencesOf: 'Test') equals: 1.	self deny: (full includes: 'Pile')! !PileTest removeSelector: #testOccurence!PileTest removeSelector: #testRemove!!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:33' prior: 33570131!example	| testPile |	self initialize.	testPile := Pile new.	self assert: testPile isEmpty.	testPile push: 1.	testPile pop.	testPile push: 2.	testPile printOn: Transcript open! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:34' prior: 33572411!example	| testPile |	self initialize.	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile pop.	testPile push: 2.	testPile printOn: Transcript open! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:34' prior: 33572690!example	| testPile |	self initialize.	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript open! !!PileTest commentStamp: 'ThomasDiGiovanni 9/20/2019 11:40' prior: 0!Test de pile!!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:43' prior: 33572969!example	| testPile |	self initialize.	testPile := self new initialize: 2.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript open! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:44' prior: 33573350!example	| testPile |	self initialize.	testPile := self new initialize: 2.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:45' prior: 33573662!example	| testPile transcript |	self initialize.	testPile := self new initialize: 2.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	transcript := Transcript open.	testPile printOn: transcript! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:45' prior: 33573969!example	| testPile |	self initialize.	testPile := self new initialize: 2.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript open! !Object subclass: #LinkedListe	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation'!Pile removeSelector: #new!!Pile class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 11:56'!new	self initialize: DefaultSize! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:56' prior: 33574319!example	| testPile |	self initialize.	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript open! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 11:57' prior: 33574898!example	| testPile |	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript open! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 11:58' prior: 33574768!new	Pile initialize: DefaultSize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 12:00' prior: 33575486!new	| newPile |	newPile := Pile new initialize: DefaultSize.	^newPile! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 12:00' prior: 33575626!new	| newPile |	newPile := self new initialize: DefaultSize.	^ newPile! !!TestPile methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!setUpsuper setUp.	empty := Pile new initialize: 3.	full := (Pile new initialize: 1) push: 'Test'! !!Pile class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!initializeDefaultSize := 5! !!Pile methodsFor: 'printing' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!printOn: aStream	aStream nextPutAll: 'Pile de taille '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu		do: [ :each | 			each printOn: aStream.			aStream space ].	aStream nextPut: $).	aStream nextPut: $.! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!initialize: taille	"La pile est vide quand index = 0, la pile est pleine quand index = capacite"	index := 0.	capacite := taille.	"Le contenu est stocké dans un tableau"	contenu := Array new: capacite! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!push: object	self isFull		ifTrue: [ self error: 'pile is full' ]		ifFalse: [ contenu at: index + 1 put: object.			index := index + 1 ]! !!Pile methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!top	^ contenu at: index! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!example	| testPile |	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript open! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 12:11'!new	| newPile |	newPile := self new initialize: DefaultSize.	^ newPile! !!Pile commentStamp: 'ThomasDiGiovanni 9/20/2019 10:16' prior: 0!Implémentation d'une pile!!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 9/20/2019 12:13'!isFull	^ index = capacite! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 9/20/2019 12:13'!isEmpty	^ index = 0! !!Pile methodsFor: 'removing' stamp: 'ThomasDiGiovanni 9/20/2019 12:13'!pop	self isEmpty		ifTrue: [ self error: 'pile is empty' ]		ifFalse: [ index := index - 1 ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/20/2019 12:13'!grow	capacite := capacite * 2! !(Smalltalk globals at: #TestPile) rename: #PileTest!!PileTest methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/20/2019 12:13' prior: 33575957!setUp	super setUp.	empty := Pile new initialize: 2.	full := (Pile new initialize: 2) push: 'Test'.	full push: 'Pile'! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/20/2019 12:13'!testInclude	self assert: (full includes: 'Test').	self assert: (full includes: 'Pile')! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 12:13' prior: 33577505!new	| newPile |	newPile := self initialize: DefaultSize.	^ newPile! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 12:14' prior: 33578682!new	| newPile |	self initialize .	newPile := self initialize: DefaultSize.	^ newPile! !----SNAPSHOT----2019-09-20T12:16:08.790285+02:00 Pharo 7.0.image priorSource: 99!----QUIT----2019-09-20T12:16:55.297963+02:00 Pharo 7.0.image priorSource: 24517!----SNAPSHOT----2019-09-20T12:21:11.405559+02:00 Pharo 7.0.image priorSource: 24600!----QUIT----2019-09-20T12:24:51.224847+02:00 Pharo 7.0.image priorSource: 24682!----QUIT/NOSAVE----2019-09-20T12:25:45.95144+02:00 Pharo 7.0.image priorSource: 24768!!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:53' prior: 33578858!new	| newPile |	newPile := super new.	self initialize.	^ newPile! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:55' prior: 33579474!new	| newPile |	newPile := super new.	newPile initialize.	^ newPile! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:56' prior: 33579649!new	^ self initialize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:58' prior: 33579827!new	^ self initialize: DefaultSize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:58' prior: 33579956!new	^ Pile initialize: DefaultSize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:58' prior: 33580098!new	^ self class initialize: DefaultSize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:58' prior: 33580240!new	^ self instanceSide initialize: DefaultSize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 14:58' prior: 33580388!new	^ self initialize: DefaultSize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 9/20/2019 15:02' prior: 33580543!new	^ (super new) initialize: DefaultSize! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/20/2019 15:04' prior: 33577231!example	| testPile |	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile printOn: Transcript! !!LinkedListe methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/20/2019 15:09'!do: index! !!LinkedListe methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/20/2019 15:10' prior: 33581096!do: block	! !!LinkedListe methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/20/2019 15:10' prior: 33581207!do: block	^'TODO'! !Object subclass: #LinkedListe	instanceVariableNames: 'value next'	classVariableNames: ''	package: 'Metaprogrammation'!----QUIT----2019-09-20T15:12:16.475202+02:00 Pharo 7.0.image priorSource: 24768!!ManifestMetaprogrammation commentStamp: 'ThomasDiGiovanni 9/26/2019 13:58' prior: 0!HMIN30? - Metaprogrammation et reflexivite!!ManifestMetaprogrammation commentStamp: 'ThomasDiGiovanni 9/26/2019 14:00' prior: 33581633!HMIN305 - Metaprogrammation et reflexivite!Object subclass: #Counter	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation'!!Counter methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 14:02'!create	|x|	x := 0.	^ [x :=x+ 1 ]! !!Boolean methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:37'!IfNotTrue: alternativeBlock	"If the receiver is true (i.e., the condition is true), then the value is the 	true alternative, which is nil. Otherwise answer the result of evaluating 	the argument, alternativeBlock. Create an error notification if the 	receiver is nonBoolean. Execution does not actually reach here because 	the expression is compiled in-line."	self subclassResponsibility! !!Boolean methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:37'!ifNotFalse: alternativeBlock	"If the receiver is false (i.e., the condition is false), then the value is the 	false alternative, which is nil. Otherwise answer the result of evaluating 	the argument, alternativeBlock. Create an error notification if the 	receiver is nonBoolean. Execution does not actually reach here because 	the expression is compiled in-line."	self subclassResponsibility! !!False methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:38'!ifNotFalse: alternativeBlock	"Since the condition is false, answer the value of the false alternative, 	which is nil. Execution does not actually reach here because the	expression is compiled in-line."	^ nil! !!False methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:38' prior: 24740107!ifFalse: alternativeBlock	"Answer the value of alternativeBlock. Execution does not actually	reach here because the expression is compiled in-line."	^ alternativeBlock value! !!False methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:39'!IfNotTrue: alternativeBlock	"Answer the value of alternativeBlock. Execution does not actually	reach here because the expression is compiled in-line."	^ alternativeBlock value! !!Boolean methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:40'!ifNotTrue: alternativeBlock	"If the receiver is true (i.e., the condition is true), then the value is the 	true alternative, which is nil. Otherwise answer the result of evaluating 	the argument, alternativeBlock. Create an error notification if the 	receiver is nonBoolean. Execution does not actually reach here because 	the expression is compiled in-line."	self subclassResponsibility! !Boolean removeSelector: #IfNotTrue:!!False methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:40'!ifNotTrue: alternativeBlock	"Answer the value of alternativeBlock. Execution does not actually	reach here because the expression is compiled in-line."	^ alternativeBlock value! !False removeSelector: #IfNotTrue:!!True methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:41'!ifNotFalse: alternativeBlock	"Answer the value of alternativeBlock. Execution does not actually 	reach here because the expression is compiled in-line."	^ alternativeBlock value! !!True methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:41' prior: 33584776!ifNotFalse: alternativeBlock	"Since the condition is true, the value is the true alternative, which is nil. 	Execution does not actually reach here because the expression is compiled 	in-line."	^ nil! !!True methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:42' prior: 33585060!ifNotFalse: alternativeBlock	"Answer the value of alternativeBlock. Execution does not actually 	reach here because the expression is compiled in-line."	^ alternativeBlock value! !!True methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 22:42'!ifNotTrue: alternativeBlock	"Since the condition is true, the value is the true alternative, which is nil. 	Execution does not actually reach here because the expression is compiled 	in-line."	^ nil! !!BlockClosure methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/26/2019 23:08'!repeatUntil^ 'TODO'! !----QUIT----2019-09-26T23:11:25.762247+02:00 Pharo 7.0.image priorSource: 27032!!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 09:57'!repeatUntil: block	^ 'TODO'! !!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 09:57' prior: 33586123!repeatUntil: block	^ self value! !BlockClosure removeSelector: #repeatUntil!!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 09:59' prior: 33586254!repeatUntil: blockblock whileFalse: [ ^ self value ]	! !!LinkedListe methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:02'!head	^ value! !!LinkedListe methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:02'!tail ^next! !!LinkedListe commentStamp: 'ThomasDiGiovanni 9/27/2019 10:03' prior: 0!Implementation d'une liste chainee!!LinkedListe methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:04'!length ^1 + self tail length! !Object subclass: #LinkedListe	instanceVariableNames: 'head tail'	classVariableNames: ''	package: 'Metaprogrammation'!!LinkedListe methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/27/2019 10:04' prior: 33586691!tail	^ tail! !!LinkedListe methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/27/2019 10:04' prior: 33586584!head	^ head! !!LinkedListe methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/27/2019 10:05' prior: 33581320!do: block	^ self head block value ! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:06'!length ^0! !!Counter class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:11'!create	| x |	x := 0.	^ [ x := x + 1 ]! !Counter removeSelector: #create!!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 10:13' prior: 33586434!repeatUntil: block	! !!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 10:23' prior: 33587797!repeatUntil: block	block value 	ifTrue: [ self repeatUntil: block ]! !!LinkedListe methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:27'!add: element! !!LinkedListe methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:27'!append: list! !!LinkedListe methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/27/2019 10:28' prior: 33588190!append: list	^ tail append: list! !Object subclass: #List	instanceVariableNames: 'head tail'	classVariableNames: ''	package: 'Metaprogrammation'!Smalltalk globals removeClassNamed: #AnObsoleteList!(Smalltalk globals at: #LinkedListe) rename: #List!!List methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/27/2019 10:30'!addFirst: element	^ List new head: element tail: self! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 10:33'!ruleReTestClassNotInPackageWithTestEndingNameV1FalsePositive	^ #()! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 10:33' prior: 33588792!ruleReTestClassNotInPackageWithTestEndingNameV1FalsePositive	^ #(#(#(#RGPackage #(#Metaprogrammation)) #'2019-09-27T10:33:24.180624+02:00') )! !TestCase subclass: #PileTest	instanceVariableNames: 'emptyInstance fullInstance'	classVariableNames: ''	package: 'Metaprogrammation'!!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/27/2019 10:33' prior: 33578487!testInclude	self assert: (fullInstance includes: 'Test').	self assert: (fullInstance includes: 'Pile')! !!PileTest methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/27/2019 10:34' prior: 33578290!setUp	super setUp.	emptyInstance := Pile new initialize: 2.	fullInstance := (Pile new initialize: 2) push: 'Test'.	fullInstance push: 'Pile'! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/27/2019 10:34'!test	self assert: (emptyInstance isEmpty).	self assert: (fullInstance isFull).! !PileTest removeSelector: #testInclude!!List methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/27/2019 10:35' prior: 33587381!do: block	^ 'TODO'! !List removeSelector: #add:!!List methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 10:37'!head: newHead tail: newTailhead := newHead.tail := newTail.! !!List methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/27/2019 10:37' prior: 33588631!addFirst: element	^ self new head: element tail: self! !!List methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/27/2019 10:41' prior: 33590276!addFirst: element	^ List new head: element tail: self! !!List methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/27/2019 10:41' prior: 33590420!addFirst: element	^ self class new head: element tail: self! !!PileTest methodsFor: 'running' stamp: 'ThomasDiGiovanni 9/27/2019 10:44' prior: 33589554!setUp	super setUp.	emptyInstance := Pile new initialize: 2.	fullInstance := Pile new initialize: 2.	fullInstance push: 'Test'.	fullInstance push: 'Pile'! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/27/2019 10:44' prior: 33589775!test	self assert: emptyInstance isEmpty.	self deny emptyInstance isFull.	self assert: fullInstance isFull! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/27/2019 10:45' prior: 33590969!test	self assert: emptyInstance isEmpty.	self deny: emptyInstance isFull.	self assert: fullInstance isFull.	self deny: fullInstance isEmpty.! !!PileTest commentStamp: 'ThomasDiGiovanni 9/27/2019 10:45' prior: 0!Jeux de test de la classe Pile!!Counter commentStamp: 'ThomasDiGiovanni 9/27/2019 10:45' prior: 0!Standart implementation of a counter.!!List commentStamp: 'ThomasDiGiovanni 9/27/2019 10:46' prior: 33586778!Standart implementation of a linked list.!!List methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 9/27/2019 10:47' prior: 33588302!append: list	^ (tail append: list) addFirst: head! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/27/2019 10:48'!addFirst: element! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/27/2019 10:48'!head^ nil! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/27/2019 10:48'!tail ^nil! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/27/2019 10:49'!append: list^ list! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/27/2019 10:50' prior: 33591863!addFirst: element	^ List new head: element tail: nil! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/27/2019 10:50'!do: block^'TODO'! !!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 10:54' prior: 33587920!repeatUntil: block	block value		ifTrue: [ self value.			self repeatUntil: block ]! !!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 10:54' prior: 33592523!repeatUntil: block	block value		ifFalse: [ self value.			self repeatUntil: block ]! !!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 10:54' prior: 33592710!repeatUntil: block	block value		ifTrue: [ ^ self ].	self value.	self repeatUntil: block! !!BlockClosure methodsFor: 'controlling' stamp: 'ThomasDiGiovanni 9/27/2019 10:55' prior: 33592898!repeatUntil: block	block value		ifTrue: [ ^ self ].	self value.	self repeatUntil: block! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/27/2019 10:58'!testIsEmpty	self assert: emptyInstance isEmpty.	self deny: emptyInstance isFull.	self assert: fullInstance isFull.	self deny: fullInstance isEmpty! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/27/2019 10:58' prior: 33593261!testIsEmpty	self assert: emptyInstance isEmpty.	self deny: fullInstance isEmpty! !!PileTest methodsFor: 'tests' stamp: 'ThomasDiGiovanni 9/27/2019 10:58'!testIsFull	self deny: emptyInstance isFull.	self assert: fullInstance isFull.! !PileTest removeSelector: #test!!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:12' prior: 33578111!grow| newPile |	newPile := Pile new initialize: capacite * 2.! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:12' prior: 33593865!grow	| newPile |	newPile := Pile new initialize: capacite * 2.	^ newPile! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:12' prior: 33594019!grow	| newPile |	newPile := self class new initialize: capacite * 2.	^ newPile! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:15' prior: 33594185!grow	| newPile |	newPile := self class new initialize: capacite * 2.	^ newPile! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:16' prior: 33594357!grow	capacite := capacite * 2.	contenu := Array new! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:17' prior: 33594529!grow	capacite := capacite * 2.	contenu := Array new: capacite! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:17' prior: 33594673!grow	capacite := capacite * 2.	contenu := (Array new: capacite) addAll: contenu.! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:18' prior: 33594827!grow|newContenu|	capacite := capacite * 2.	newContenu := Array new: capacite.	newContenu addAll: contenu.! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 9/27/2019 11:18' prior: 33595000!grow	| newContenu |	capacite := capacite * 2.	newContenu := Array new: capacite.	newContenu addAll: contenu.	contenu := newContenu! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 9/27/2019 11:22' prior: 33576631!initialize: taille	"La pile est vide quand index = 0, la pile est pleine quand index = capacite"	index := 0.	capacite := taille.	"Le contenu est stocke dans un tableau"	contenu := Array new: capacite! !!Pile class methodsFor: 'example' stamp: 'ThomasDiGiovanni 9/27/2019 11:27' prior: 33580824!example	| testPile |	testPile := self new.	self assert: testPile isEmpty.	testPile push: 1.	testPile push: 2.	testPile pop.	testPile push: 3.	testPile inspect! !Object subclass: #Inspecter	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation'!!Inspecter methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 9/27/2019 11:37'!inspect: object! !!Inspecter commentStamp: 'ThomasDiGiovanni 9/27/2019 11:38' prior: 0!Class able to inspect any object and print its attributes and methods in the transcript.!!Inspecter commentStamp: 'ThomasDiGiovanni 9/27/2019 11:39' prior: 33596195!Class able to inspect any object and print its attributes' names and values in the transcript.!!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:39' prior: 33596105!inspect: object	Transcript.! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:40' prior: 33596550!inspect: object	Transcript show: 'TODO'! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:41' prior: 33596674!inspect: object	Transcript show: 'Hello'! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:41' prior: 33596810!inspect: object	Transcript show: 'Hello world'! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:42' prior: 33596947!inspect: object	Transcript show: object properties! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 11:44'!ruleRBCodeCruftLeftInMethodsRuleV1FalsePositive	^ #()! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 11:44' prior: 33597248!ruleRBCodeCruftLeftInMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#Inspecter)) #'2019-09-27T11:44:03.468624+02:00') )! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:44' prior: 33597090!inspect: object	Transcript show: object properties; cr! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:45' prior: 33597650!inspect: object	Transcript		show: object allClassVarNames;		cr! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:49' prior: 33597801!inspect: object	Transcript		show: object allInstVarNames;		cr! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:50' prior: 33597962!inspect: object	Transcript	show: object name, ' attributes are ';		show: object allInstVarNames;		cr! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:51' prior: 33598122!inspect: object	Transcript		show: object name , ' attributes are ', object allInstVarNames;		cr! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:52' prior: 33598322!inspect: object	Transcript		show: object name , ' attributes are: '; cr; show: object allInstVarNames;		cr! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:56' prior: 33598516!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.		1 to: object allInstVarNames size do: [:varName |  Transcript show: varName, ' ', object instVarNamed: varName asSymbol; cr]		show: object allInstVarNames;		cr! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 11:56' prior: 33598721!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1		to: object allInstVarNames size			do: [ :varName | 			Transcript				show: varName , ' ' , object instVarNamed: varName asSymbol;				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:02' prior: 33599057!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varName | 		Transcript			show: object allIsntVarNames at: varName , ' ' , object instVarNamed: varName asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:02' prior: 33599375!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varName | 		Transcript			show: object allInstVarNames				at: varName , ' ' , object				instVarNamed: varName asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:02' prior: 33599712!inspect: object	Transcript		show: object name asString , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varName | 		Transcript			show: object allInstVarNames				at: varName , ' ' , object				instVarNamed: varName asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:02' prior: 33600057!inspect: object	Transcript		show: object name, ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varName | 		Transcript			show: object allInstVarNames				at: varName , ' ' , object				instVarNamed: varName asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:03' prior: 33600411!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show: object allInstVarNames				at: varNameIndex , ' ' , (object				instVarNamed: (object allInstVarNames				at: varNameIndex)) asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:03' prior: 33600755!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show: (object allInstVarNames				at:				varNameIndex) , ' '					,						(object instVarNamed: (object allInstVarNames at: varNameIndex))							asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:04' prior: 33601150!inspect: object	Transcript		show: object , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show:				(object allInstVarNames at: varNameIndex) , ' '					,						(object instVarNamed: (object allInstVarNames at: varNameIndex))							asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:04' prior: 33601561!inspect: object	Transcript		show: object asString , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show:				(object allInstVarNames at: varNameIndex) , ' '					,						(object instVarNamed: (object allInstVarNames at: varNameIndex))							asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:05' prior: 33601963!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show:				(object allInstVarNames at: varNameIndex) , ' '					,						(object instVarNamed: (object allInstVarNames at: varNameIndex))							asSymbol;			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:06' prior: 33602374!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show:				(object allInstVarNames at: varNameIndex) , ' '					,						(object instVarNamed: (object allInstVarNames at: varNameIndex)							asSymbol);			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:14' prior: 33602781!inspect: object	Transcript		show: object title , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show:				(object allInstVarNames at: varNameIndex) , ' '					,						(object							instVarNamed: (object allInstVarNames at: varNameIndex) asSymbol);			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:21' prior: 33603188!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex | 		Transcript			show:				(object allInstVarNames at: varNameIndex) , ' '					,						(object							instVarNamed: (object allInstVarNames at: varNameIndex) asSymbol);			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:22' prior: 33603596!inspect: object| varName|	Transcript		show: object name , ' attributes are: ';		cr.	1 to: object allInstVarNames size do: [ :varNameIndex |		varName := object allInstVarNames at: varNameIndex.		Transcript			show:				varName, ' '					,						(object							instVarNamed: varName asSymbol);			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:26' prior: 33604003!inspect: object	Transcript		show: object name , ' attributes are: ';		cr.	object allInstVarNames do: [ :varName | 		Transcript			show:				varName , ' ' , (object instVarNamed: varName asSymbol);			cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:28' prior: 33604405!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol);				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:31' prior: 33604710!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol);				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:31' prior: 33605021!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object class instVarNamed: varName asSymbol);				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:32' prior: 33605338!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol);				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:32' prior: 33605661!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName);				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:32' prior: 33605978!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol);				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:32' prior: 33606286!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol) asString;				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/27/2019 12:33' prior: 33606603!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol) asString;				cr ]! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 12:36'!ruleRBBadMessageRuleV1FalsePositive	^ #()! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 12:36' prior: 33607266!ruleRBBadMessageRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#Inspecter)) #'2019-09-27T12:36:13.763624+02:00') )! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 12:36'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #()! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 9/27/2019 12:36' prior: 33607655!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#Inspecter)) #'2019-09-27T12:36:43.094624+02:00') )! !----SNAPSHOT----2019-09-27T12:37:02.230624+02:00 Pharo 7.0.image priorSource: 31525!----QUIT----2019-09-27T12:37:07.792624+02:00 Pharo 7.0.image priorSource: 53516!!List methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/27/2019 23:09' prior: 33589990!do: block	^ head value: block! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/28/2019 00:07' prior: 33606929!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol);				cr ]! !!Inspecter methodsFor: 'actions' stamp: 'ThomasDiGiovanni 9/28/2019 00:08' prior: 33608334!inspect: object	Transcript		show: object className , ' attributes are: ';		cr.	object class allInstVarNames		do: [ :varName | 			Transcript				show: varName , ' ' , (object instVarNamed: varName asSymbol) asString;				cr ]! !----QUIT----2019-09-28T01:06:51.61433+02:00 Pharo 7.0.image priorSource: 53602!!List methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/28/2019 20:01' prior: 33608208!do: block	^ head value: head! !!List methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/28/2019 20:01' prior: 33609057!do: block	^ block value: head! !!List methodsFor: 'enumerating' stamp: 'ThomasDiGiovanni 9/28/2019 20:01' prior: 33609181!do: block	block value: head.	block value: tail! !!List methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/28/2019 20:07' prior: 33590564!addFirst: element	^ self class new head: element tail: (head append: tail)! !!List methodsFor: 'adding' stamp: 'ThomasDiGiovanni 9/28/2019 20:07' prior: 33609444!addFirst: element	^ self class new head: element tail: self! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/28/2019 20:14' prior: 33592403!do: block! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/28/2019 20:17' prior: 33592267!addFirst: element	^ List with: element! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/28/2019 20:18' prior: 33609877!addFirst: element	^ List head: element tail: nil! !!UndefinedObject methodsFor: 'list' stamp: 'ThomasDiGiovanni 9/28/2019 20:18' prior: 33610015!addFirst: element	^ List new head: element tail: nil! !----QUIT----2019-09-28T20:24:25.150204+02:00 Pharo 7.0.image priorSource: 54452!Object subclass: #IDM	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'!!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 09:57'!idmPile! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/4/2019 10:01' prior: 33580685!new	^ self basicNew initialize: DefaultSize! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/4/2019 10:03' prior: 33610613!new	^ self basicNew! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 10:06' prior: 33595200!grow	| newContenu |	capacite := capacite * 2.	newContenu := Array new: capacite.	newContenu putAll: contenu.	contenu := newContenu! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 10:11' prior: 33610875!grow	| newContenu |	capacite := capacite * 2.	newContenu := Array new: capacite.	newContenu do: [ :each :i | newContenu at: i put: (contenu at: i) ].	contenu := newContenu! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 10:11' prior: 33611101!grow	| newContenu |	capacite := capacite * 2.	newContenu := Array new: capacite.	contenu do: [ :each | newContenu at: each put: (contenu at: each) ].	contenu := newContenu! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 10:13' prior: 33611368!grow	| newContenu newCapacite |	newCapacite := capacite * 2.	newContenu := Array new: newCapacite.	contenu do: [ :each | newContenu at: each put: (contenu at: each) ].	contenu := newContenu.	capacite := newCapacite.! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:23' prior: 33610499!idmPile| multMethod |	multMethod :=OpalCompiler new	source: 'mult: y\ ^self = 0 ifTrue: [0] ifFalse: [^y + ((self - 1) mult: y)]' withCRs	class: Integer	compile.! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:24' prior: 33611964!idmPile	| multMethod |	multMethod := OpalCompiler new		source:			'mult: y\ ^self = 0 ifTrue: [0] ifFalse: [^y + ((self - 1) mult: y)]'				withCRs;		class: Integer; compile! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:25' prior: 33612238!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source:			'Pile subclass: #growingPile'				withCRs;		compile! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:28' prior: 33612523!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source: 'Pile subclass: #growingPile		instanceVariableNames: ''''		classVariableNames: ''''		package: ''Metaprogrammation-TP1''' withCRs;		compile! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:28' prior: 33612764!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source:			'Pile subclass: #growingPile		instanceVariableNames: ''''		classVariableNames: ''''		package: ''Metaprogrammation-TP1''' withCRs.			growingPileClass compile.! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:34' prior: 33613092!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source:			'Pile subclass: #GrowingPile		instanceVariableNames: ''''		classVariableNames: ''''		package: ''Metaprogrammation-TP1''' withCRs.			growingPileClass compile.! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:35' prior: 33613443!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source:			'#Pile subclass: #GrowingPile		instanceVariableNames: ''''		classVariableNames: ''''		package: ''Metaprogrammation-TP1''' withCRs.	growingPileClass compile! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:41' prior: 33613794!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source:			'Pile subclass: #GrowingPile		instanceVariableNames: ''''		classVariableNames: ''''		package: ''Metaprogrammation-TP1''' withCRs;		class: Pile.	growingPileClass compile! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:43' prior: 33614142!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source:			'Object subclass: #GrowingPile		instanceVariableNames: ''''		classVariableNames: ''''		package: ''Metaprogrammation-TP1''' withCRs;		class: Pile.	growingPileClass compile! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:43' prior: 33614504!idmPile	| growingPileClass |	growingPileClass := OpalCompiler new		source:			'Object subclass: #GrowingPile		instanceVariableNames: ''''		classVariableNames: ''''		package: ''Metaprogrammation-TP1''' withCRs.	growingPileClass compile! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:50' prior: 33614868!idmPile		Pile addSubclass: #GrowingPile;	addSelector: #grow withMethod: (Pile compiledMethodAt: #grow).	Pile removeSelector: #grow! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:56' prior: 33615217!idmPile	Pile		addSubclass: #GrowingPile;		addSelector: #grow withMethod: (Pile compiledMethodAt: #grow).	"Pile removeSelector: #grow"! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:56' prior: 33615459!idmPile	Pile		addSubclass: 'GrowingPile';		addSelector: #grow withMethod: (Pile compiledMethodAt: #grow)	"Pile removeSelector: #grow"! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 10:56' prior: 33615704!idmPile	Pile		addSubclass: #GrowingPile;		addSelector: #grow withMethod: (Pile compiledMethodAt: #grow)	"Pile removeSelector: #grow"! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:05' prior: 33611635!grow	| oldContenu oldCapacite |	oldCapacite := capacite.	oldContenu := contenu.	capacite := oldCapacite * 2.	contenu := Array new: capacite.	0 to: oldCapacite do: [ :i |  self push: (oldContenu at: i)]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:06' prior: 33616176!grow	| oldContenu oldCapacite |	oldCapacite := capacite.	oldContenu := contenu.	capacite := oldCapacite * 2.	contenu := Array new: capacite.	1 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:08' prior: 33616474!grow	| oldContenu oldCapacite |	oldCapacite := capacite.	oldContenu := contenu.	index := 0.	capacite := oldCapacite * 2.	contenu := Array new: capacite.	1 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:09' prior: 33615949!idmPile	Pile subclass: #GrowingPile	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'.		#GrowingPile addSelector: #grow withMethod: (Pile compiledMethodAt: #grow)	"Pile removeSelector: #grow"! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:10' prior: 33617100!idmPile	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	GrowingPile		addSelector: #grow		withMethod: (Pile compiledMethodAt: #grow)	"Pile removeSelector: #grow"! !Smalltalk globals removeClassNamed: #AnObsoleteGrowingPile!!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:11' prior: 33617438!idmPile	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	GrowingPile		addSelector: #grow		withMethod: (Pile compiledMethodAt: #grow).	Pile removeSelector: #grow! !GrowingPile removeSelector: #grow!Smalltalk globals removeClassNamed: #AnObsoleteGrowingPile!!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:16'!grow	| oldCapacite oldContenu |	oldCapacite := self size.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	0 to: oldCapacite do: [ :i |  self push: (oldContenu at: i)]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:17' prior: 33618262!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	0 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:17' prior: 33618558!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	index := 0.	capacite := capacite * 2.	contenu := Array new: capacite.	0 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:17' prior: 33618853!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	0 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:18' prior: 33619161!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:21' prior: 33617843!idmPile|tempMethod|	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	GrowingPile		addSelector: #grow		withMethod: (Pile compiledMethodAt: #grow).	Pile removeSelector: #grow! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:21' prior: 33619794!idmPile	| tempMethod |	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.		tempMethod := Pile compiledMethodAt: #grow.	GrowingPile		addSelector: #grow		withMethod: tempMethod .	Pile removeSelector: #grow! !GrowingPile removeSelector: #grow!Smalltalk globals removeClassNamed: #AnObsoleteGrowingPile!!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:24'!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !GrowingPile removeSelector: #grow!Smalltalk globals removeClassNamed: #AnObsoleteGrowingPile!!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:33'!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:34' prior: 33621013!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: oldCapacite do: [ :i | i isNotNil ifTrue: [self push: (oldContenu at: i) ]]! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 10/4/2019 11:35' prior: 33577847!isEmpty	^ index = 1! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 10/4/2019 11:35' prior: 33577746!isFull	^ index = capacite + 1! !!Pile methodsFor: 'adding' stamp: 'ThomasDiGiovanni 10/4/2019 11:36' prior: 33576911!push: object	self isFull		ifTrue: [ self error: 'pile is full' ]		ifFalse: [ contenu at: index put: object.			index := index + 1 ]! !!Pile methodsFor: 'testing' stamp: 'ThomasDiGiovanni 10/4/2019 11:36' prior: 33621761!isFull	^ index = (capacite + 1)! !!Pile methodsFor: 'initialization' stamp: 'ThomasDiGiovanni 10/4/2019 11:36' prior: 33595433!initialize: taille	index := 1.	capacite := taille.	"Le contenu est stocke dans un tableau"	contenu := Array new: capacite! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:38' prior: 33621321!grow	| oldIndex oldContenu |	oldContenu := contenu.	oldIndex := index.		capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: oldIndex do: [ :i | 		i isNotNil			ifTrue: [ self push: (oldContenu at: i) ] ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:38' prior: 33622453!grow	| oldContenu oldIndex  |	oldContenu := contenu.	oldIndex := index.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: oldIndex do: [ :i | 		i isNotNil			ifTrue: [ self push: (oldContenu at: i) ] ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:38' prior: 33622780!grow	| oldContenu oldIndex |	oldContenu := contenu.	oldIndex := index.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 1.	1 to: oldIndex do: [ :i | 		i isNotNil			ifTrue: [ self push: (oldContenu at: i) ] ]! !!Pile methodsFor: 'printing' stamp: 'ThomasDiGiovanni 10/4/2019 11:38' prior: 33576253!printOn: aStream	aStream nextPutAll: 'Pile de taille '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant '.	index - 1 printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu		do: [ :each | 			each printOn: aStream.			aStream space ].	aStream nextPut: $).	aStream nextPut: $.! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:39' prior: 33623106!grow	| oldContenu oldIndex |	oldContenu := contenu.	oldIndex := index.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 1.	1 to: oldIndex do: [ :i |self push: (oldContenu at: i) ]! !!Pile methodsFor: 'private' stamp: 'ThomasDiGiovanni 10/4/2019 11:40' prior: 33623823!grow	| oldContenu oldIndex |	oldContenu := contenu.	oldIndex := index.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 1.	1 to: oldIndex - 1 do: [ :i | self push: (oldContenu at: i) ]! !GrowingPile removeSelector: #grow!!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:50' prior: 33620150!idmPile	| tempMethod pushMethod |	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.			tempMethod := OpalCompiler new 	source: (Pile compiledMethodAt: #grow) sourceCode;	class: GrowingPile;	compile.	GrowingPile addSelector: #grow withMethod: tempMethod.	Pile removeSelector: #grow.		pushMethod := OpalCompiler new	source: 'push: object	self isFull		ifTrue: [ self grow. ]		contenu at: index put: object.		index := index + 1' withCRs;		class: GrowingPile;		compile.	GrowingPile addSelector: #push: withMethod: pushMethod.! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:51' prior: 33624471!idmPile	| tempMethod pushMethod |	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	tempMethod := OpalCompiler new		source: (Pile compiledMethodAt: #grow) sourceCode;		class: GrowingPile;		compile.	GrowingPile addSelector: #grow withMethod: tempMethod.	Pile removeSelector: #grow.	pushMethod := OpalCompiler new		source:		'push: object			self isFull			ifTrue: [ self grow. ]			contenu at: index put: object.			index := index + 1' withCRs;		class: GrowingPile;		compile.	GrowingPile addSelector: #push: withMethod: pushMethod! !Smalltalk globals removeClassNamed: #AnObsoleteGrowingPile!!Pile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:52'!grow	| oldCapacite oldContenu |	oldCapacite := capacite.	oldContenu := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: oldCapacite do: [ :i | self push: (oldContenu at: i) ]! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:52' prior: 33625186!idmPile	| tempMethod pushMethod |	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	tempMethod := OpalCompiler new		source: (Pile compiledMethodAt: #grow) sourceCode;		class: GrowingPile;		compile.	GrowingPile addSelector: #grow withMethod: tempMethod.	"Pile removeSelector: #grow."		pushMethod := OpalCompiler new		source:			'push: object			self isFull			ifTrue: [ self grow. ]			contenu at: index put: object.			index := index + 1' withCRs;		class: GrowingPile;		compile.	GrowingPile addSelector: #push: withMethod: pushMethod! !Smalltalk globals removeClassNamed: #AnObsoleteGrowingPile!!GrowingPile methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:53' prior: 0!push: arg1	self isFull ifTrue: [ self grow ]. contenu at: index put: arg1.	index := index + 1! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:53' prior: 33626270!idmPile	| tempMethod pushMethod |	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	tempMethod := OpalCompiler new		source: (Pile compiledMethodAt: #grow) sourceCode;		class: GrowingPile;		compile.	GrowingPile addSelector: #grow withMethod: tempMethod.	"Pile removeSelector: #grow."	pushMethod := OpalCompiler new		source:			'push: object			self isFull			ifTrue: [ self grow. ].			contenu at: index put: object.			index := index + 1' withCRs;		class: GrowingPile;		compile.	GrowingPile addSelector: #push: withMethod: pushMethod! !Object subclass: #Cellule	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'!!Cellule methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:55'!compileFormula: s! !!Cellule methodsFor: 'compiling' stamp: 'ThomasDiGiovanni 10/4/2019 11:56'!executeFormula: s	! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:57' prior: 33627252!idmPile	| growingPileClass tempMethod pushMethod |	"Adds a new class"	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.				"Moves the grow method"	tempMethod := OpalCompiler new		source: (Pile compiledMethodAt: #grow) sourceCode;		class: GrowingPile;		compile.	GrowingPile addSelector: #grow withMethod: tempMethod.	Pile removeSelector: #grow.	pushMethod := OpalCompiler new		source:			'push: object			self isFull			ifTrue: [ self grow. ].			contenu at: index put: object.			index := index + 1' withCRs;		class: GrowingPile;		compile.	GrowingPile addSelector: #push: withMethod: pushMethod! !!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:58' prior: 33628294!idmPile	| growingPileClass tempMethod pushMethod |	"Adds a new class"	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	growingPileClass := Smalltalk classNamed: GrowingPile.		"Moves the grow method"	tempMethod := OpalCompiler new		source: (Pile compiledMethodAt: #grow) sourceCode;		class: GrowingPile;		compile.	GrowingPile addSelector: #grow withMethod: tempMethod.	Pile removeSelector: #grow.	pushMethod := OpalCompiler new		source:			'push: object			self isFull			ifTrue: [ self grow. ].			contenu at: index put: object.			index := index + 1' withCRs;		class: GrowingPile;		compile.	GrowingPile addSelector: #push: withMethod: pushMethod! !Smalltalk globals removeClassNamed: #AnObsoleteGrowingPile!!IDM class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 11:59' prior: 33629081!idmPile	| growingPileClass tempMethod pushMethod |	"Adds a new class"	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	growingPileClass := Smalltalk classNamed: #GrowingPile.	"Moves the grow method"	tempMethod := OpalCompiler new		source: (Pile compiledMethodAt: #grow) sourceCode;		class: growingPileClass;		compile.	growingPileClass addSelector: #grow withMethod: tempMethod.	Pile removeSelector: #grow.		"Redefines the push method"	pushMethod := OpalCompiler new		source:			'push: object			self isFull			ifTrue: [ self grow. ].			contenu at: index put: object.			index := index + 1' withCRs;		class: growingPileClass;		compile.	growingPileClass addSelector: #push: withMethod: pushMethod! !Pile removeSelector: #grow!!GrowingPile commentStamp: 'ThomasDiGiovanni 10/4/2019 12:01' prior: 0!Class created programmatically by the call "IDM idmPile".!!IDM commentStamp: 'ThomasDiGiovanni 10/4/2019 12:02' prior: 0!Meta!!Cellule methodsFor: 'compiling' stamp: 'ThomasDiGiovanni 10/4/2019 12:02' prior: 33628070!compileFormula: string	! !!Cellule methodsFor: 'compiling' stamp: 'ThomasDiGiovanni 10/4/2019 12:06'!executeFormula	! !Cellule removeSelector: #executeFormula:!Object subclass: #Cellule	instanceVariableNames: 'value formula internalFormula dependsFrom'	classVariableNames: ''	package: 'Metaprogrammation-TP1'!!Cellule methodsFor: 'compiling' stamp: 'ThomasDiGiovanni 10/4/2019 12:08' prior: 33631197!executeFormula	formula isNil		ifFalse: [ UndefinedObject				addSelector: #execFormula				withMethod: internalFormula.			^ nil executeFormula ]		ifTrue: [ self error ]! !!Cellule methodsFor: 'compiling' stamp: 'ThomasDiGiovanni 10/4/2019 12:10' prior: 33631506!executeFormulaformula isNil ifFalse:[UndefinedObject addSelector:#executeFormula withMethod: internalFormula.^nil executeFormula]ifTrue:[self error]! !Object subclass: #Cellule	instanceVariableNames: 'value formula internalFormula'	classVariableNames: ''	package: 'Metaprogrammation-TP1'!----SNAPSHOT----2019-10-04T12:25:42.875531+02:00 Pharo 7.0.image priorSource: 55787!!Cellule commentStamp: 'ThomasDiGiovanni 10/4/2019 12:27' prior: 0!Implementation of a cell on a table.!!Symbol methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/4/2019 12:27'!catch! !!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:29'!returnToCatchwith: a! !!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:29'!catch: block	block value.! !!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:29' prior: 33632431!returnToCatchwith: value	! !!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:30' prior: 33632653!returnToCatchwith: value	|catchMethod currentContext|	currentContext :=thisContext.	catchMethod :=Symbol compiledMethodAt:#catch:.[currentContext method==catchMethod and:[currentContext receiver==self]]whileFalse:[currentContext :=currentContext sender].currentContext return: value.^value! !Symbol removeSelector: #catch!!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:31' prior: 33632775!returnToCatchwith: value	| catchMethod currentContext |	currentContext := thisContext.	catchMethod := Symbol compiledMethodAt: #catch:.			[ currentContext method == catchMethod		and: [ currentContext receiver == self ] ]		whileFalse: [ currentContext := currentContext sender ].	currentContext return: value.	^ value! !!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:31' prior: 33633196!returnToCatchwith: value	| catchMethod currentContext |	currentContext := thisContext.	catchMethod := self class compiledMethodAt: #catch:.	[ currentContext method == catchMethod		and: [ currentContext receiver == self ] ]		whileFalse: [ currentContext := currentContext sender ].	currentContext return: value.	^ value! !!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:32' prior: 33633618!returnToCatchwith: value	| catchMethod currentContext |	currentContext := thisContext.	catchMethod := self compiledMethodAt: #catch:.	[ currentContext method == catchMethod		and: [ currentContext receiver == self ] ]		whileFalse: [ currentContext := currentContext sender ].	currentContext return: value.	^ value! !!Symbol methodsFor: 'exceptions' stamp: 'ThomasDiGiovanni 10/4/2019 12:32' prior: 33634040!returnToCatchwith: value	| catchMethod currentContext |	currentContext := thisContext.	catchMethod := self class compiledMethodAt: #catch:.	[ currentContext method == catchMethod		and: [ currentContext receiver == self ] ]		whileFalse: [ currentContext := currentContext sender ].	currentContext return: value.	^ value! !(Smalltalk globals at: #Cellule) rename: #Cell!!Cell commentStamp: 'ThomasDiGiovanni 10/4/2019 12:34' prior: 33632223!Implementation of a cell in a spreadsheet.!----QUIT----2019-10-04T12:34:53.456531+02:00 Pharo 7.0.image priorSource: 77636!!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:47' prior: 33610764!new	^ super new! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:47' prior: 33635137!new	^ super new initialize! !Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'defaultSize'	package: 'Metaprogrammation-TP1'!!Pile class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 10/11/2019 09:47' prior: 33576150!initialize	defaultSize := 5! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:48' prior: 33635261!new	^ super new! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:48' prior: 33635678!new	| newInstance |	newInstance := super new.	^ newInstance! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:51' prior: 33635802!new	| newInstance |	newInstance := super new initialize: defaultSize.	^ newInstance! !Object subclass: #Citoyen	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'!!Citoyen commentStamp: 'ThomasDiGiovanni 10/11/2019 09:55' prior: 0!Implementation of a citizen!!IDM commentStamp: 'ThomasDiGiovanni 10/11/2019 09:56' prior: 33630995!Meta stuff.!!Citoyen commentStamp: 'ThomasDiGiovanni 10/11/2019 09:56' prior: 33636244!Implementation of a citizen.!Object subclass: #Citoyen	instanceVariableNames: 'president'	classVariableNames: ''	package: 'Metaprogrammation-TP1'!Pile class	instanceVariableNames: 'instanceList'!!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:57' prior: 33635972!new	| newInstance |	newInstance := super new initialize: defaultSize.		instanceList add: newInstance.		^ newInstance! !!Pile class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 10/11/2019 09:58' prior: 33635542!initialize	DefaultSize := 5! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:58' prior: 33636742!new	| newInstance |	newInstance := super new initialize: DefaultSize.		instanceList add: newInstance.		^ newInstance! !!Pile class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 10/11/2019 09:58' prior: 33636975!initialize	DefaultSize := 5! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 09:58' prior: 33637111!new	| newInstance |	newInstance := super new initialize: DefaultSize.		instanceList add: newInstance.		^ newInstance! !!Pile class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 10/11/2019 09:59' prior: 33637344!initialize	DefaultSize := 5.	instanceList := Collection new! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:00'!instances^instanceList ! !!Pile class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:00' prior: 33637866!instances	^ instanceList! !!Pile class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 10/11/2019 10:02' prior: 33637713!initialize	DefaultSize := 5.	instanceList := LinkedList new! !!Pile commentStamp: 'ThomasDiGiovanni 10/11/2019 10:03' prior: 33577647!Classic implementation of a stack!Object subclass: #SalleCours	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'!!SalleCours commentStamp: 'ThomasDiGiovanni 10/11/2019 10:05' prior: 0!Implementation of a university room!!SalleCours commentStamp: 'ThomasDiGiovanni 10/11/2019 10:05' prior: 33638495!Implementation of a university room.!SalleCours class	instanceVariableNames: 'maxRooms'!!SalleCours class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:05'!new! !!SalleCours class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:05' prior: 33638799!new	| newInstance |	newInstance := super new initialize.	instanceList add: newInstance.	^ newInstance! !!SalleCours class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:06' prior: 33638917!new	| newInstance |	newInstance := super new.	instanceList add: newInstance.	^ newInstance! !!SalleCours class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:07'!initializemaxRooms := 5! !!SalleCours class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 10/11/2019 10:07' prior: 33639330!initialize	maxRooms := 5.	instanceList := LinkedList new! !!SalleCours class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:09' prior: 33639136!new	| newInstance |	newInstance := super new.	(instanceList size + 1 >= maxRooms)	ifTrue: [  ] ifFalse: [ 	instanceList add: newInstance.	^ newInstance ]! !!SalleCours class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:10' prior: 33639643!new	| newInstance |	newInstance := super new.	instanceList size + 1 <= maxRooms		ifTrue: [ instanceList add: newInstance.			^ newInstance ]		ifFalse: [ self error: 'Max capacity reached.' ]! !SalleCours class	instanceVariableNames: 'maxRooms roomCount'!!SalleCours class methodsFor: 'class initialization' stamp: 'ThomasDiGiovanni 10/11/2019 10:11' prior: 33639471!initialize	maxRooms := 5.	roomCount := 0! !!SalleCours class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:12' prior: 33639916!new	| newInstance |	newInstance := super new.	roomCount + 1 <= maxRooms		ifTrue: [ roomCount := roomCount + 1.			^ newInstance ]		ifFalse: [ self error: 'Max capacity reached.' ]! !!SalleCours class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:12' prior: 33640448!new	roomCount + 1 <= maxRooms		ifTrue: [ roomCount := roomCount + 1.			^ super new ]		ifFalse: [ self error: 'Max capacity reached.' ]! !Object subclass: #Animal	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'!!Animal commentStamp: 'ThomasDiGiovanni 10/11/2019 10:14' prior: 0!Abstract class representing an animal.!Animal subclass: #Chien	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'!Animal subclass: #Chat	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-TP1'!!Chat commentStamp: 'ThomasDiGiovanni 10/11/2019 10:14' prior: 0!Representation of a cat.!!Chien commentStamp: 'ThomasDiGiovanni 10/11/2019 10:14' prior: 0!Representation of a dog.!!Animal class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:15'!new ! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:15' prior: 33641606!new	self error: 'Cannot instanciate an abstract class'	! !!Chat class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:17'!new	super new.! !!Chat class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:17' prior: 33641871!new	^super new! !!IDM class methodsFor: 'creating' stamp: 'ThomasDiGiovanni 10/11/2019 10:32' prior: 33629983!idmPile	| growingPileClass growMethod pushMethod |	"Adds a new class"	Pile		subclass: #GrowingPile		instanceVariableNames: ''		classVariableNames: ''		package: 'Metaprogrammation-TP1'.	growingPileClass := Smalltalk classNamed: #GrowingPile.	"Moves the grow method"	growMethod := OpalCompiler new		source: (Pile compiledMethodAt: #grow) sourceCode;		class: growingPileClass;		compile.	growingPileClass addSelector: #grow withMethod: growMethod.	Pile removeSelector: #grow.	"Redefines the push method"	pushMethod := OpalCompiler new		source:			'push: object			self isFull			ifTrue: [ self grow. ].			contenu at: index put: object.			index := index + 1' withCRs;		class: growingPileClass;		compile.	growingPileClass addSelector: #push: withMethod: pushMethod! !!IDM commentStamp: 'ThomasDiGiovanni 10/11/2019 10:32' prior: 33636345!Refactoring stuff.!!Chat class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:33' prior: 33641994!new	^ self basicNew! !!Chat class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:33' prior: 33643090!new	^ super new! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:35' prior: 33641721!new	self subclassResponsibility ! !Chat class removeSelector: #new!!Chat class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:36'!new! !!Chien class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:36'!new! !Animal class removeSelector: #new!!Animal methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:39'!initialize self error: 'Cannot instanciate an abstract class'! !!Chat class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:40' prior: 33643505!new	super new! !!Cell methodsFor: 'compiling' stamp: 'ThomasDiGiovanni 10/11/2019 10:43' prior: 33631774!executeFormula	formula isNil		ifTrue: [ self error ]		ifFalse: [ UndefinedObject				addSelector: #executeFormula				withMethod: internalFormula.			^ nil executeFormula ]! !Object subclass: #Citoyen	instanceVariableNames: ''	classVariableNames: 'president'	package: 'Metaprogrammation-TP1'!!Citoyen methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:48'!changepresident := 'new'! !!Citoyen methodsFor: 'accessing' stamp: 'ThomasDiGiovanni 10/11/2019 10:48' prior: 33644398!change	president := 'new'.	^ president! !!Citoyen methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:49'!initialize	president := 'temp'! !!Citoyen class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:49'!intialize	president := 'old'! !!Citoyen class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 10:50'!initialize	president := 'old'! !Citoyen class removeSelector: #intialize!Citoyen removeSelector: #change!Citoyen removeSelector: #initialize!Citoyen class removeSelector: #initialize!!Class methodsFor: 'subclass creation' stamp: 'ThomasDiGiovanni 10/11/2019 10:53' prior: 19109646!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: catself halt.	^ self classInstaller		make: [ :builder | 			builder				superclass: self;				name: t;				layoutClass: self classLayout class;				slots: f asSlotCollection;				sharedVariablesFromString: d;				sharedPools: s;				category: cat;				environment: self environment;				copyClassSlotsFromExistingClass ]! !ClassDescription subclass: #Test	instanceVariableNames: 'subclasses name classPool sharedPools environment category'	classVariableNames: ''	package: 'Kernel-Classes'!Smalltalk globals removeClassNamed: #AnObsoleteTest!!Class methodsFor: 'subclass creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:07' prior: 33645197!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat	^ self classInstaller		make: [ :builder | 			builder				superclass: self;				name: t;				layoutClass: self classLayout class;				slots: f asSlotCollection;				sharedVariablesFromString: d;				sharedPools: s;				category: cat;				environment: self environment;				copyClassSlotsFromExistingClass ]! !Animal removeSelector: #initialize!!Animal class methodsFor: 'as yet unclassified' stamp: 'ThomasDiGiovanni 10/11/2019 11:08'!newself error: 'Cannot instanciate an abstract class'! !!Chien class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:09' prior: 33643603!new	^super new! !!Chat class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:09' prior: 33643902!new	^super new! !!Chat class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:10' prior: 33646755!new	^ self basicNew! !!Chien class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:10' prior: 33646632!new	^ self basicNew! !!Class methodsFor: 'subclass creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:15' prior: 33645936!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: catself halt.	^ self classInstaller		make: [ :builder | 			builder				superclass: self;				name: t;				layoutClass: self classLayout class;				slots: f asSlotCollection;				sharedVariablesFromString: d;				sharedPools: s;				category: cat;				environment: self environment;				copyClassSlotsFromExistingClass ]! !!Class methodsFor: 'subclass creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:23' prior: 33647130!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat	^ self classInstaller		make: [ :builder | 			builder				superclass: self;				name: t;				layoutClass: self classLayout class;				slots: f asSlotCollection;				sharedVariablesFromString: d;				sharedPools: s;				category: cat;				environment: self environment;				copyClassSlotsFromExistingClass ]! !!Class methodsFor: 'subclass creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:32' prior: 33647644!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: catself halt.	^ self classInstaller		make: [ :builder | 			builder				superclass: self;				name: t;				layoutClass: self classLayout class;				slots: f asSlotCollection;				sharedVariablesFromString: d;				sharedPools: s;				category: cat;				environment: self environment;				copyClassSlotsFromExistingClass ]! !Chat class removeSelector: #new!Chien class removeSelector: #new!!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:58' prior: 33646469!new	self == Animal	ifTrue: [ self error: 'Cannot instanciate an abstract class' ]IfFalse: [ ^super new ]	! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:58' prior: 33648737!new	self == Animal class		ifTrue: [ self error: 'Cannot instanciate an abstract class' ]		IfFalse: [ ^ super new ]! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 11:59' prior: 33648956!new	self = Animal class		ifTrue: [ self error: 'Cannot instanciate an abstract class' ]		IfFalse: [ ^ super new ]! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 12:00' prior: 33649183!new	self = Animal class		ifTrue: [ self error: 'Cannot instanciate an abstract class' ]		ifFalse: [ ^ super new ]! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 12:01' prior: 33649409!new	self = Animal		ifTrue: [ self error: 'Cannot instanciate an abstract class' ]		ifFalse: [ ^ super new ]! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 12:01' prior: 33649635!new	self = Animal		ifTrue: [ self error: 'Cannot instanciate an abstract class (', self name, ')' ]		ifFalse: [ ^ super new ]! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 12:05' prior: 33649855!new	self = self class		ifTrue: [ self				error: 'Cannot instanciate an abstract class (' , self name , ')' ]		ifFalse: [ ^ super new ]! !!Animal class methodsFor: 'instance creation' stamp: 'ThomasDiGiovanni 10/11/2019 12:05' prior: 33650093!new	self = Animal		ifTrue: [ self				error: 'Cannot instanciate an abstract class (' , self name , ')' ]		ifFalse: [ ^ super new ]! !PackageManifest subclass: #MetaprogrammationManifest	instanceVariableNames: ''	classVariableNames: ''	package: 'Metaprogrammation-Manifest'!Smalltalk globals removeClassNamed: #AnObsoleteMetaprogrammationManifest!!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 10/11/2019 12:20'!ruleRBRefersToClassRuleV1FalsePositive	^ #()! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 10/11/2019 12:20' prior: 33650803!ruleRBRefersToClassRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'Animal class' #new #true)) #'2019-10-11T12:20:22.960371+02:00') )! !----SNAPSHOT----2019-10-11T12:31:45.993371+02:00 Pharo 7.0.image priorSource: 80518!ManifestMetaprogrammation class removeSelector: #ruleReTestClassNotInPackageWithTestEndingNameV1FalsePositive!!EpLogBrowserPresenter methodsFor: 'modes' stamp: 'AutoDeprecationRefactoring 10/11/2019 12:35' prior: 23224528!beRevertMode	self title: 'Epicea - Revert Changes'.	self toolbarPresenter beRevertMode.	showEntryItemMenu := false! !!ManifestMetaprogrammation class methodsFor: 'code-critics' stamp: 'ThomasDiGiovanni 10/11/2019 12:35'!ruleReTestClassNotInPackageWithTestEndingNameV1FalsePositive	^ #(#(#(#RGPackage #(#Metaprogrammation)) #'2019-09-27T10:33:24.180624+02:00') )! !----QUIT----2019-10-11T12:37:28.797371+02:00 Pharo 7.0.image priorSource: 96680!----QUIT----2019-10-11T12:38:57.391854+02:00 Pharo 7.0.image priorSource: 97362!!RawObjTest commentStamp: 'StephaneDucasse 11/17/2014 11:09' prior: 0!These tests are based on a setup that does not rely on structure for the accessors.!!ObjClassInspector commentStamp: 'StephaneDucasse 11/16/2014 23:11' prior: 0!I'm a simple inspector that can inspect fixed structured Obj class."creating class by hand"| coloredPointClass |coloredPointClass := Obj new: 6.coloredPointClass at: coloredPointClass offsetForName put: #ObjColoredPoint.coloredPointClass at: coloredPointClass offsetForClass put: #ObjClass.coloredPointClass at: coloredPointClass offsetForIVs put: #( #class #x #y #color).coloredPointClass at: coloredPointClass offsetForSuperclass put: #ObjPoint.coloredPointClass at: coloredPointClass offsetForMethodDict	put: (IdentityDictionary new).coloredPointClass.ObjClassInspector basicInspect: coloredPointClass.!!ObjExampleTest class methodsFor: 'first user-defined metaclasses'!setMetaclassDefinition	"self setMetaclassDefinition"	| setClass |	setClass := Obj ObjClass				send: #new				withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	"initialize on a metaclass"	setClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself'.	setClass addUnaryMethod: #instances		withBody: 'objself binarySend: #getIV with: #myInstances'.	setClass addMethod: #new		args: 'initArray'		withBody: 			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: 'StephaneDucasse 11/26/2014 22:04'!setMetaclassExample	"self setMetaclassExample"	| memoPointClass |	self setMetaclassDefinition.	memoPointClass := Obj ObjSet 						send: #new						withArguments: #(#(#name: #ObjMemoPoint  #iv: #() #superclass: #ObjPoint)).	memoPointClass send: #new withArguments: #(#(#x: 24 #y: 6)).	memoPointClass send: #new withArguments: #(#(#x: 15 #y: 10)).	^memoPointClass send: #instances withArguments: #().! !!ObjExampleTest methodsFor: 'setup'!abstractMetaclassDefinition 	(Obj giveClassNamed: #ObjClass)					 		send: #new							withArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).	Obj ObjAbstractClass 		addMethod: #new		args: 'initArray'		withBody: 			' objself error: '' the class '' , objself objName asString , '' is abstract'''! !!ObjExampleTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:52'!defineObjAbstractPoint	(Obj ObjAbstractClass)		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex		withBody: 'objself  valueOfInstanceVariable: #x '.	Obj ObjAbstractPoint 		addUnaryMethod: #display		withBody: 			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself send: #givex withArguments: #()) printString;				cr'.! !!ObjExampleTest methodsFor: 'setup'!defineObjPoint	Obj ObjClass send: #new		withArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint)).! !!ObjExampleTest methodsFor: 'setup'!setUp	Obj bootstrap.	self abstractMetaclassDefinition.	self defineObjAbstractPoint.	self defineObjPoint! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExample	self should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExampleWithConcreteSubclass	self shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract' stamp: 'StephaneDucasse 11/27/2014 20:48'!testColoredPoint	| coloredPointClass aColoredPoint |	coloredPointClass := (Obj ObjClass)						 	send: #new 							withArguments: #((#name: #ObjColoredPoint 							           		   #iv: #(#color) 							            	  #superclass: #ObjPoint)).	aColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).		"first messages sent"	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 24.	aColoredPoint send: #setIV withArguments: #(#x 25).	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 25.	self assert: (aColoredPoint send: #getIV withArguments: #(#color)) = #blue.		"adding some methods"	coloredPointClass 		addUnaryMethod: #giveColor		withBody: 'objself send: #getIV withArguments: #(#color)'.	coloredPointClass 		addMethod: #setColor		args: 'col'		withBody:' objself send: #setIV withArguments: (Array with: #color with: col)'.	coloredPointClass addUnaryMethod: #display		withBody:  			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self assert: (aColoredPoint send: #giveColor withArguments: #()) = #blue.		self assert: (aColoredPoint send: #givex withArguments: #()) = 25.		aColoredPoint send: #display withArguments: #().! !!ObjMessageTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 15:33'!setUp	Obj bootstrap.	Obj objClassStructureMessage.! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMessageClassMethods	"self debug: #testMessageClassMethods"		| msg |	Obj addMessagesForErrorHandling.	msg := Obj ObjMessage 				send: #new 				withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg send: #receiver2 withArguments: #()) equals: 24.	self assert: (msg send: #receiver withArguments: #()) equals: 24.	self assert: (msg send: #selector withArguments: #()) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg send: #arguments withArguments: #())  equals: #(25).! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 14:52'!testMessageClassMethodsDefined	"self debug: #testMessageClassMethodsDefined"		| msg |	Obj addMessagesForErrorHandling.	self deny: Obj ObjMessage objMethodDict size isZero! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 10:16'!testMessageClassStructureDeclared	Obj objClassStructureMessage.	self assert: Obj ObjMessage objName = #ObjMessage.	self assert: Obj ObjMessage objClass objName= #ObjClass.	self assert: Obj ObjMessage objIVs asArray = #(#class #receiver #selector #arguments).	self assert: Obj ObjMessage objSuperclass = Obj ObjObject	! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 15:05'!testUsingPrimitivesMessageClassMethods	| msg |	msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg at: 1) equals: #ObjMessage.	self assert: (msg at: 2) equals: 24.	self assert: (msg at: 3) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg at: 4)  equals: #(25).! !!ObjTest methodsFor: 'setup'!assembleClassClass	classClass := Obj new: 6.	classClass at: classClass offsetForName put: #ObjClass.	classClass at: classClass offsetForClass put: #ObjClass.	classClass at: classClass offsetForIVs		put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: classClass offsetForKeywords		put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: classClass offsetForSuperclass put: #ObjObject.	classClass at: classClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 10/22/2009 16:24'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:36'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: pointClass offsetForName put: #ObjColoredPoint.	coloredPointClass at: pointClass offsetForClass put: #ObjClass.		"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: pointClass offsetForIVs put: #( #class #x #y #color).	coloredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	coloredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:10'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:37'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: pointClass offsetForName put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: pointClass offsetForClass put: #ObjClass.		"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: pointClass offsetForIVs put: #( #color).	incrementalColoredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	incrementalColoredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 16:01'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: objectClass offsetForName put: #ObjObject.	objectClass at: objectClass offsetForClass put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :arrayOfArguments | 			Transcript show: 'Error: selector ' , arrayOfArguments first printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!ObjTest methodsFor: 'setup'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: pointClass offsetForName put: #ObjPoint.	pointClass at: pointClass offsetForClass put: #ObjClass.	pointClass at: pointClass offsetForIVs put: #(#class #x #y).	pointClass at: pointClass offsetForKeywords put: #(#x: #y:).	pointClass at: pointClass offsetForSuperclass put: #ObjObject.	pointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!ObjTest methodsFor: 'setup'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:15'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!ObjTest methodsFor: 'step5-tests-allocate' stamp: 'StephaneDucasse 11/21/2015 15:44'!testAllocate  "(self  selector: #testAllocate) run"  | newInstance |  newInstance := pointClass allocateAnInstance.  self assert: (newInstance at: 1) = #ObjPoint.  self assert: (newInstance size) = 3.  self assert: (newInstance at: 2) isNil.  self assert: (newInstance at: 3) isNil.  self assert: (newInstance objClass = pointClass)! !!ObjTest methodsFor: 'utilities tests'!testBlockArgsFrom	self assert: (Obj new blockArgsFrom: ' abc def ghi ')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: 'abc def ghi')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: '')  = ''.! !!ObjTest methodsFor: 'utilities tests' stamp: 'NicoPAez 10/21/2010 10:22'!testBlockBodyFromHeaderAndBody	"a method with one argument: val"	self assert: (Obj new stringOfBlockBodyFromHeader: 'val' andBody: 'objself send: #setIV 										 withArguments: (Array with: #x with: val).')										= '[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] ]'.	"a method without arg"	self assert: (Obj new stringOfBlockBodyFromHeader: '' andBody: 'objself unarySend: #getx.') 	='[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] ]'	! !!ObjTest methodsFor: 'step3-tests-class access'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testErrorRaisedSendWhenErrorInLookup	"(self  selector: #testErrorRaisedSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 21:15'!testErrorRedefinition	"(self  run: #testErrorRedefinition)"		self should: [aPoint send: #zork withArguments: #()] raise: Error.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).		self assert: (aPoint send: #zork withArguments: #()) = 33.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).	self assert: (aPoint send: #zork withArguments: #(44)) = 33.! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffset	"(self  selector: #testIVOffset) run"	self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu ) = 0)! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffsetAndValue	"(self  selector: #testIVOffsetAndValue) run"	self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aPoint valueOfInstanceVariable: #x ) = 10)! !!ObjTest methodsFor: 'step7-tests-initialize' stamp: 'StephaneDucasse 11/21/2015 16:16'!testInitialize	"(self  selector: #testInitialize) run"	| newInstance  |	newInstance := pointClass allocateAnInstance.	newInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self assert: (newInstance at: 1) equals: #ObjPoint.	self assert: (newInstance at: 2) equals: 1.	self assert: (newInstance at: 3) equals: 2.! !!ObjTest methodsFor: 'step8-tests-instance variable inheritance'!testInstanceVariableInheritance	"(self  selector: #testInstanceVariableInheritance) run"	"a better choice would be to throw an exception if there are duplicates"	self assert: 			((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #b #c #d #z #t) asOrderedCollection).	self assert: 			((Obj new computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #z #b #t) asOrderedCollection)! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:12'!testInstanceVariableInheritanceFromAClass	"(self  selector: #testInstanceVariableInheritanceFromAClass) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x ) = 2).	! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:14'!testInstanceVariableInheritanceFromAObject	"(self  selector: #testInstanceVariableInheritanceFromAObject) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x ) = 2).			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/9/2009 16:52'!testInstanceVariableInheritanceNotFind	"(self  selector: #testInstanceVariableInheritanceNotFind) run"		self should: [aPoint offsetFromObjectOfInstanceVariable: #zork ] raise: Error.			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/13/2009 16:23'!testInstanceVariableInheritanceNumberOfInstanceVar	"(self  selector: #testInstanceVariableInheritanceNumberOfInstanceVar) run"		self assert: ((pointClass numberOfIVs ) = 3).	self assert: ((coloredPointClass numberOfIVs ) = 4).	! !!ObjTest methodsFor: 'step6-tests-keywords'!testKeywords	"(self  selector: #testKeywords) run"	| dummyObject |	dummyObject := Obj new.	self assert: 			((dummyObject generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:)).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 33 #x 23)				ifAbsent: 2) = 23).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 23)				ifAbsent: 2) = 2).	self assert: 			((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))				= #(35 nil 22 35))! !!ObjTest methodsFor: 'tests'!testMethodDefinition	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.	"define a unary method xx returning the receiver."	pointClass 		addMethod: #xx		args: ''		withBody: 'objself'.	self assert: (pointClass doesUnderstand: #xx).	self assert: (((pointClass bodyOfMethod: #xx) value: 22) = 22).	"define a unary method returning the slot x of the receiver"	pointClass 		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self assert: (pointClass doesUnderstand: #getgetx).	self assert: (((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookup	"(self  selector: #testMethodLookup) run"		self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSimpleMethod	"(self  selector: #testMethodLookupFindSimpleMethod) run"	self assert: ((pointClass lookup: #x)  isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSuperMethod	"(self  selector: #testMethodLookupFindSuperMethod) run"		self assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:38'!testMethodLookupStop	"(self  selector: #testMethodLookupStop) run"		| foundMethod|	foundMethod := (pointClass lookup: #zork).	self assert: foundMethod isNil. 	"The method zork is NOT implement on pointClass, so nil is returned."	self should: [ pointClass sendError: #error withArgs: {aPoint}] raise: Error.		foundMethod := (pointClass lookup: #error).	self assert: (foundMethod isKindOf: BlockClosure).	self assert: ('*Error*' match: foundMethod printString).		"the message error defined on ObjObject requires two arguments: an object and a selector and it raises 	an error when executed. Open a Transcript to see the message trace"	self should:  [((pointClass lookup: #zork) value: 'r' value: #e)] raise: Error .! !!ObjTest methodsFor: 'tests' stamp: 'NicoPAez 10/21/2010 10:25'!testMethodManagement	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.		pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentAddRemoveMethods	"(self  selector: #testMethodManagmentAddRemoveMethods) run"	pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentBodyOfMethod	"(self  selector: #testMethodManagmentBodyOfMethod) run"		self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentNotUnderstandBadMethod	"(self  selector: #testMethodManagmentNotUnderstandBadMethod) run"	self assert: (pointClass doesUnderstand: #xx) not.	! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentUnderstandGoodMethod	"(self  selector: #testMethodManagmentUnderstandGoodMethod) run"	self assert: (pointClass doesUnderstand: #x).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMethodNotFoundRaiseError	"(self  run: #testMethodNotFoundRaiseError)"	self should: [aPoint send: #zork withArguments: #()] raise: Error.! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 12:18'!testMethodSelfSend	"(self  selector: #testMethodSelfSend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in ObjClass"	self assert: ((aPoint send: #getIV withArguments: #(#x)) = 10).	"method found in ObjClass"	aPoint send: #setIV withArguments: #(y 22).	self assert: ((aPoint send: #getIV withArguments: #(#y)) = 22)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSelfSendUnarySend	"(self  selector: #testMethodSelfSendUnarySend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in the class PointClass"	self assert: ((aColoredPoint send: #x withArguments:#()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSuperCall	"(self  selector: #testMethodSuperCall) run"	"foo in point return 5"	self assert: ((aPoint send: #foo withArguments: #()) = 5).	"foo in colored point is doing super foo + super foo"	self assert: ((aColoredPoint send: #foo withArguments: #()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:23'!testMethodSuperCallOverBigHierarchy	"(self  selector: #testMethodSuperCallOverBigHierarchy) run"	"bar is defined in Object and not on Point"	self assert: (aPoint send: #bar withArguments: #()) = 5.	"bar on coloredPoint = super bar + super bar"	self assert: (aColoredPoint send: #bar withArguments: #()) = 10.! !!ObjTest methodsFor: 'utilities tests'!testMethodWithHeaderAndBody	"a method simply returning objself"	self assert: ((pointClass					methodWithHeader: ''					andBody: 'objself ') value: 2) = 2.		"a method returning its first none implicit arg"	self assert: ((pointClass 					methodWithHeader: 'val'					andBody: 'val ') value: 2 value: 33) = 33.	"a method returns its superclass of the class defining the method value"	"this anonymous method is defined in pointClass so its superclass pointer is objectClass"	self assert: ((pointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = objectClass .	self assert: ((coloredPointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = pointClass .! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testNilWhenErrorInLookup	"(self  selector: #testNilWhenErrorInLookup) run"		self assert: (pointClass lookup: #zork) isNil.	"The method zork is NOT implement on pointClass"	! !!ObjTest methodsFor: 'tests' stamp: 'SD 2/5/2013 16:47'!testPrimitiveStructure	"(self selector: #testPrimitiveStructure) run"		self assert: (pointClass objClassId = #ObjClass).	self assert: ((pointClass objName ) = #ObjPoint).	self assert: ((pointClass objSuperclassId ) = #ObjObject).	self assert: ((pointClass objIVs) = #(#class #x #y)).	self assert: ((pointClass objKeywords) = #(#x: #y:)).	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'SD 2/5/2013 16:48'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/21/2015 18:24'!testRaisesErrorSendWhenErrorInLookup	"(self  selector: #testRaisesErrorSendWhenErrorInLookup) run"	self should: [ pointClass send: #zork withArguments: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:54'!testSendErrorRaisesErrorSendWhenErrorInLookup	"(self  selector: #testSendErrorRaisesErrorSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:56'!testCreateObjClassMessage	"(self selector: #testCreateObjClassMessage) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: ((objClass send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass)).	self assert: (objClass send: #isClass withArguments: #()).	self assert: (objClass send: #isMetaclass withArguments: #())! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:57'!testCreateObjClassStructure	"(self selector: #testCreateObjClassStructure) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objSuperclassId = #ObjObject).	self assert: (objClass objIVs asArray = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords asArray = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 21:59'!testCreateObjObjectInstanceMessage	"(self selector: #testCreateObjObjectInstanceMessage) run"	| pointClass objClass pointInstance |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objClass := Obj giveClassNamed: #ObjClass.	pointClass := objClass 							send: #new							withArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).	pointInstance := pointClass send: #new withArguments: #(#()).	self assert: (pointInstance objClassId = #ObjPoint).	self assert: ((pointInstance send: #getIV withArguments: #(#x)) = nil).	pointInstance send: #setIV withArguments: #(#x 25).	self assert:  ((pointInstance send: #getIV withArguments: #(x)) = 25 )! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 22:00'!testCreateObjObjectMessage	"(self selector: #testCreateObjObjectMessage) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass).	self assert: (objObject send: #isClass withArguments: #()) not.	self assert: (objObject send: #getIV withArguments: #(#class)) = #ObjClass! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'stephane.ducasse 9/29/2008 14:32'!testCreateObjObjectStructure	"(self selector: #testCreateObjObjectStructure) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject objName = #ObjObject).	self assert: (objObject objClassId = #ObjClass).	self assert: (objObject objSuperclassId isNil).	self assert: (objObject objIVs asArray = #(#class)).	self assert: (objObject objKeywords asArray = #())! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassAllocate	"(self selector: #testManuallyCreateObjClassAllocate) run"	| objClass emptyClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	emptyClass := objClass send: #allocate withArguments: #().	self assert: emptyClass objClassId = #ObjClass.	self assert:  emptyClass objSuperclassId isNil.	self assert:  emptyClass objIVs isNil.	self assert:  emptyClass objKeywords isNil.	self assert:  emptyClass objMethodDict isNil.	self assert:  emptyClass objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassStructure	"(self selector: #testManuallyCreateObjClassStructure) run"	| objClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objClass == objClass).	self assert: (objClass objSuperclassId = #ObjObject).		"the fact that the created first class inherits form ObjObject is not necessary	because there is no super calls"	self assert: (objClass objIVs = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:10'!assembleClassClass	classClass := Obj new: 6.	classClass at: 2 put: #ObjClass.	classClass at: 1 put: #ObjClass.	classClass at: 4 put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: 3 put: #ObjObject.	classClass at: 6 put: (IdentityDictionary new).	Obj declareClass: classClass! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:38'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: 2 put: #ObjColoredPoint.	coloredPointClass at: 1 put: #ObjClass.	"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: 4 put: #( #class #x #y #color).	coloredPointClass at: 3 put: #ObjPoint.	coloredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:39'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: 2 put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: 1 put: #ObjClass.	"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: 4 put: #( #color).	incrementalColoredPointClass at: 3 put: #ObjPoint.	incrementalColoredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:12'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: 2 put: #ObjObject.	objectClass at: 1 put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :selector | 			Transcript show: 'Error: selector ' , selector printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:13'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: 2 put: #ObjPoint.	pointClass at: 1 put: #ObjClass.	pointClass at: 4 put: #(#class #x #y).	pointClass at: 5 put: #(#x: #y:).	pointClass at: 3 put: #ObjObject.	pointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!RawObjTest methodsFor: 'step3-tests-class access' stamp: 'StephaneDucasse 11/17/2014 11:09'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMessagesForErrorHandling	"pre condition message has been created (and declared)"	"self addMessagesForErrorHandling"	| objMessage |	objMessage := self ObjMessage.	objMessage 		addUnaryMethod: #receiver 		withBody: 'objself valueOfInstanceVariable: #receiver'.	objMessage 		addUnaryMethod: #receiver2 		withBody: 'objself send: #getIV withArguments: #(#receiver)'.	objMessage 		addUnaryMethod: #selector 		withBody: 'objself send: #getIV withArguments: #(#selector)'.			objMessage 		addUnaryMethod: #arguments 		withBody: 'objself send: #getIV withArguments: #(#arguments)'.		objMessage 		addMethod: #setReceiver		args: 'receiver'		withBody:' objself send: #setIV withArguments: (Array with: #receiver with: receiver)'.			objMessage 		addMethod: #setSelector		args: 'selector'		withBody:' objself send: #setIV withArguments: (Array with: #selector with: selector)'.	objMessage 		addMethod: #setArguments		args: 'arguments'		withBody:' objself send: #setIV withArguments: (Array with: #arguments with: arguments)'.							^ objMessage ! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!bootstrap	"self bootstrap"		self initialize.	self manuallyCreateObjClass.	self createObjObject.	self createObjClass.! !!Obj class methodsFor: 'meta data' stamp: 'StephaneDucasse 1/1/2018 20:14'!classInstanceVariables	^ #(#class #name #superclass #iv #keywords #methodDict)! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjClass	"self bootstrap"	| objClass |	objClass := self objClassStructure.	self defineAllocateMethodIn: objClass.	self defineNewMethodIn: objClass.	self defineInitializeMethodIn: objClass.	objClass 		addUnaryMethod: #isMetaclass		withBody: 'objself objIVs includes: #superclass'.		"an object is a class if is class is a metaclass. cool"		objClass 		addUnaryMethod: #isClass		withBody: 'objself objClass send: #isMetaclass withArguments:#()'.	^objClass! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjObject	| objObject |	objObject := self objObjectStructure.	objObject addUnaryMethod: #class withBody: 'objself objClass'.	objObject addUnaryMethod: #isClass withBody: 'false'.	objObject addUnaryMethod: #isMetaclass withBody: 'false'. 	objObject 		addMethod: #error		args: 'arrayOfArguments'		withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first'.	"some meta facilities"	objObject 		addMethod: #getIV		args: 'iv'		withBody: 'objself valueOfInstanceVariable: iv'.	objObject 		addMethod: #setIV		args: 'iv val'		withBody: 			' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val'.	objObject 		addMethod: #initialize		args: 'initargs'		withBody: 'objself  initializeUsing: initargs'.	^objObject! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!declareClass: anObjClass 	"To declare an ObjClass in the class repository"	| nameC |	nameC := anObjClass objName.	nameC isNil		ifFalse: [definedObjClasses at: nameC put: anObjClass]		ifTrue: [self error: 'The class does not have a name']! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineAllocateMethodIn: class 	"The allocated obj method simply invokes the primitive allocateAnInstance."		class 		addUnaryMethod: #allocate 		withBody: 'objself allocateAnInstance'! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineInitializeMethodIn: objClass 	objClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineManualInitializeMethodIn: class 	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineNewMethodIn: class 	class 		addMethod: #new		args: 'initArray'		withBody: 			'(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } '.! !!Obj class methodsFor: 'tricks' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesNotUnderstand: aMessage	"debugging >>>  default shiftDown ifTrue:[ self halt ]."	"Sensor shiftPressed ifTrue:[ self halt ]."		^ definedObjClasses at: aMessage selector! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol 	"Return the class defined in the class repository with the name aSymbol"	^ self giveClassNamed: aSymbol ifAbsent: [self error: ('The class ' , aSymbol printString , ' is not defined')]! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol ifAbsent: aBlock	^ definedObjClasses at: aSymbol ifAbsent: aBlock! !!Obj class methodsFor: 'initialize' stamp: 'StephaneDucasse 1/1/2018 20:14'!initialize	"self initialize"	 	definedObjClasses := IdentityDictionary new.	definedObjClasses at: #ObjClass put: nil.	definedObjClasses at: #ObjObject put: nil.	definedObjClasses at: #ObjMessage put: nil.! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manualObjClassStructure	| class |	class := Obj new: 6.	class objClassId: #ObjClass.	class objName: #ObjClass.	class objIVs: self classInstanceVariables.	class objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:).	class objSuperclassId: #ObjObject.	class objMethodDict: (IdentityDictionary new: 3).	^ class! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manuallyCreateObjClass	"self manuallyCreateObjClass"	| class |	class := self manualObjClassStructure.	Obj declareClass: class.	self defineManualInitializeMethodIn: class.	self defineNewMethodIn: class.	self defineAllocateMethodIn: class.	^class! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructure	^(Obj giveClassNamed: #ObjClass) send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructureMessage	^ Obj ObjClass 		send: #new		withArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!objObjectStructure	^(Obj giveClassNamed: #ObjClass) 		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!Obj class methodsFor: 'skeleton metadata' stamp: 'StephaneDucasse 1/1/2018 20:14'!selectorsToSkeletonize	"Skeletonizer new 		selectors: Obj selectorsToSkeletonize;		sourceClassName: #Obj;		targetClassName: #ObjSkeleton;		installClass;		skeletonize		"	^ #(objIVs objIVs: objKeywords objKeywords: objMethodDict objMethodDict: objName objName: objSuperclassId objSuperclassId: objClass objClassId objClassId: allocateAnInstance offsetFromClassOfInstanceVariable: offsetFromObjectOfInstanceVariable: valueOfInstanceVariable: #send:withArguments: #super:withArguments:from: lookup: bodyOfMethod:)! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMethod: aSelector args: aString withBody: aStringBlock 	"Define a method with selector <aSelector> , having a string representing the arguments (ie 'aNumber aStream') 	and a string representing the method body in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  objMethodDict at: aSelector put: (self methodWithHeader: aString andBody: aStringBlock).	^self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addUnaryMethod: aSelector withBody: aStringBlock 	"Define a unary method with selector <aSelector> and a body <aaStringBlock> in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  addMethod: aSelector args: '' withBody: aStringBlock! !!Obj methodsFor: 'instance allocation' stamp: 'StephaneDucasse 1/1/2018 20:14'!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!basicSend: selector withArguments: arguments from: aClass	"Execute the method found starting from aClass and whose name is selector."	"The core of the sending a message, reused for both a normal send or a super one."		| methodOrNil |	methodOrNil := aClass lookup: selector.	^ methodOrNil 		ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ] 		ifNil: [ self sendError: selector withArgs: arguments ] ! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!blockArgsFrom: aCol	"self basicNew blockArgsFrom: ' abc def ghi '"			| col st |	col := aCol findTokens: Character space.	col := col copyWithout: ''.	st := ''.	col do: [ :each | st := st , ':', each ] separatedBy: [st := st, ' '].	^ st! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	^ self! !!Obj methodsFor: 'debugging' stamp: 'StephaneDucasse 1/1/2018 20:14'!classDebug	"(self giveClassNamed: #ObjClass) classDebug"	"(self giveClassNamed: #ObjSet) classDebug"	ObjClassInspector basicInspect: self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeAndSetKeywords	"Compute the keywords of a given class.  As the class of an object should not be changed.	 the keywords should note contain the keyword class. self is anObjClass"	self objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFrom: superIVOrdCol with: localIVOrdCol	"Returns an ordered collection that is the union without duplicate of ivOfSuper and ivOrderedCollection.	Important the order of the instance variable is conserved"	| ivs |	^superIVOrdCol isNil 		ifTrue: [localIVOrdCol]		ifFalse: 			[ivs := superIVOrdCol asOrderedCollection copy.			localIVOrdCol do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFromClass: anObjClass with: ivOrderedCollection 	"Obj computeNewIVFromClass: #(#C #C #O #(a b c d)) with: #(a z b t) asOrderedCollection"	| ivs |	^anObjClass isNil		ifTrue: [ivOrderedCollection]		ifFalse: 			[ivs := anObjClass objIVs asOrderedCollection copy.			ivOrderedCollection do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesUnderstand: aSelector 	"Tell if the receiver has a method having <aSelector> as selector. self is anObjClass"	^self objMethodDict keys includes: aSelector! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!generateKeywords: anArray 	"Returns an array containing the keywords made from the collection of Symbol passed as argument"	"self new generateKeywords: #(titi toto lulu) "	^anArray collect: [:e | (e , ':') asSymbol]! !!Obj methodsFor: 'instance initialization' stamp: 'StephaneDucasse 1/1/2018 20:14'!initializeUsing: anAlternatedArray 	"Returns the receiver an ObjObject initialized according to the directives given by anAlternateArray"	| ivValues |	ivValues := self 						returnValuesFrom: anAlternatedArray						followingSchema: self objClass objKeywords.	1 to:  ivValues size			do: [:i | self at: i + 1 put: (ivValues at: i)].	^ self ! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!keywordValue: aSymbol getFrom: anArray ifAbsent: aDefaultValue 	"precondition: ((length anArray) mod 2) = 0 	returns the value associated with the keyword represented by aSymbol 	in the initarg list represented by anArray."	"self new keywordValue: #titi getFrom: #(toto 12 titi 23) ifAbsent: 2"	"self new keywordValue: #titi getFrom: #(toto 23) ifAbsent: 2"	| i |	i := anArray indexOf: aSymbol ifAbsent: nil.	^i isNil 		ifTrue: [aDefaultValue] 		ifFalse: [anArray at: i + 1]! !!Obj methodsFor: 'method lookup' stamp: 'StephaneDucasse 1/1/2018 20:14'!lookup: selector	"look for the method named <selector> starting in the receiver. 	The lookup is done for a message sent to <anObjObject>. self is an objClass"	^ self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!methodWithHeader: col andBody: aString 	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler evaluate: string.	"bind superclass to the superclass of the class defining the method"	resBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).	^resBlock! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!numberOfIVs	"Returns the number of instance variables of the class an ObjClass"	^self objIVs size! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClass	"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId	"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId: anObjClassId	"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs	"Receiver should be: anObjClass. Returns the list of instance variables"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs: anOrderedCollection	"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords	"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords: anOrderedCollection	"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict	"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict: aDictionary	"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName: aName	"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclass	"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"	^Obj giveClassNamed: self objSuperclassId! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId	"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId: anObjClassId	"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'object structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForClass	^1! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForIVs	^4! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForKeywords	^5! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForMethodDict	^6! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForName	^2! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForSuperclass	^3! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromClassOfInstanceVariable: aSymbol	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	^ self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromObjectOfInstanceVariable: aSymbol	"Returns the offset of the instance variable named aSymbol in the object anObjObject.	If aSymbol is not an instance variable is not an instance variable of the object raise an error"	^ self! !!Obj methodsFor: 'printing' stamp: 'StephaneDucasse 1/1/2018 20:14'!printOn: aStream	aStream nextPutAll: 'an Obj object: '.		super printOn: aStream! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!removeMethod: aSelector	"Remove the method with aSelector <aSymbol> in the receiver. 	self is an objClass"	self objMethodDict removeKey: aSelector ifAbsent: [].	^self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!returnValuesFrom: anInitargArray followingSchema: anArrayOfKeywords 	"Return the values associated with the keys. The extracted values are taken from <anInitargArray> 	and the return values are extracted according to the schema defined by the collection of keys <anArrayOfKeywords>"	"self new returnValuesFrom: #(lulu 22  titi 35)  followingSchema: #(titi toto lulu titi)  #(35 nil 22 35)"	^anArrayOfKeywords collect: 			[:e | 			self keywordValue: e				getFrom: anInitargArray 				ifAbsent: nil]! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!send: selector withArguments: arguments	"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!sendError: selector withArgs: arguments	"send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."		^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}	! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!stringOfBlockBodyFromHeader: col andBody: aString 	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: col) , ' |					 ' , aString , '] ]'! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!super: selector withArguments: arguments from: aSuperclass	"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"	^ self! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!valueOfInstanceVariable: aSymbol	^ self! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure		^ orderedStructure! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure: anObject		orderedStructure := anObject! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!value	^ self host basicAt: (self orderedStructure indexOf: index)! !!ObjClassInspector methodsFor: 'list' stamp: 'StephaneDucasse 11/16/2014 23:10'!addVariableFields: elements		| classStructure |	classStructure := Obj classInstanceVariables.	classStructure do: [ :key |		elements add: (StrictlyOrderedEyeElement new 								orderedStructure: classStructure;								host: self object;								index: key; 								yourself)]! !"ObjVSkeleton"!Object subclass: #ObjClass	instanceVariableNames: 'classId, name, superclassId, instanceVariablesList, initializationKeywordsList, methodDict'	classVariableNames: ''	package: 'Metaprogrammation-Project'!!Class methodsFor: 'subclass creation' stamp: 'ThomasDiGiovanni 11/22/2019 11:38' prior: 33648147!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat	"self halt."	^ self classInstaller		make: [ :builder | 			builder				superclass: self;				name: t;				layoutClass: self classLayout class;				slots: f asSlotCollection;				sharedVariablesFromString: d;				sharedPools: s;				category: cat;				environment: self environment;				copyClassSlotsFromExistingClass ]! !Object subclass: #ObjClass	instanceVariableNames: 'objClassId objName objSuperclassId objIVs objKeywords objMethodDict'	classVariableNames: ''	package: 'Metaprogrammation-Project'!!ObjClass commentStamp: 'ThomasDiGiovanni 11/22/2019 11:49' prior: 0!Implementation of the class Class of ObjvLisp!Object subclass: #ObjClass	instanceVariableNames: 'objClassId objName objSuperclassId objIVs objKeywords objMethodDict'	classVariableNames: ''	package: 'Metaprogrammation-Project'!Object subclass: #ObjClass	instanceVariableNames: 'objClassId objName objSuperclassId objIVs objKeywords objMethodDict'	classVariableNames: ''	package: 'Metaprogrammation-Project' !Object subclass: #ObjClass	instanceVariableNames: 'objClassId objName objSuperclassId objIVs objKeywords objMethodDict'	classVariableNames: ''	package: 'Metaprogrammation-Project'!!ObjClass commentStamp: 'ThomasDiGiovanni 11/22/2019 11:50' prior: 33720586!Implementation of the class Class of ObjvLisp.!----SNAPSHOT----2019-11-22T12:27:00.031757+01:00 Pharo 7.0.image priorSource: 97444!----SNAPSHOT----2019-11-22T12:44:59.837757+01:00 Pharo 7.0.image priorSource: 166881!----QUIT----2019-11-22T12:45:11.010757+01:00 Pharo 7.0.image priorSource: 166967!